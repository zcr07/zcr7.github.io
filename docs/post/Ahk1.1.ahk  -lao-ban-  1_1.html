<!DOCTYPE html>
<html data-color-mode="light" data-dark-theme="dark_colorblind" data-light-theme="light" lang="zh-CN">
<head>
    <meta content="text/html; charset=utf-8" http-equiv="content-type" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link href='https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/Primer/21.0.7/primer.css' rel='stylesheet' />
    
    <link rel="icon" href="https://cdn.jsdelivr.net/gh/zb9678/img@main/im8/05.03:15:58:50.png"><script>
        let theme = localStorage.getItem("meek_theme") || "light";
        document.documentElement.setAttribute("data-color-mode", theme);
    </script>
<meta name="description" content="```
#Requires AutoHotkey v1.1.36
Menu, Tray, Icon, %A_ScriptDir%\Lib\0\Library.ico  ; 自定义托盘图标
Menu, Tray, Tip, Ahk1.1                                    ; 托盘提示

#NoEnv                                                             ; 不使用旧环境变量
#SingleInstance Force                                      ; 防止重复运行
SendMode Input                                              ; 更快的发送方式
#WinActivateForce                                           ; 强制激活窗口
#ClipboardTimeout -1                                      ; 剪贴板永不超时
SetWorkingDir, %A_ScriptDir%                        ; 以脚本目录为工作目录
SetTitleMatchMode, 2                                      ; 设置窗口标题匹配为“包含”
DetectHiddenWindows, On                             ; 可以操作隐藏窗口

; 以下性能优化设置请根据需求决定是否保留
;SetBatchLines, 10ms                                        ; -1 为最大性能（高CPU）
;Process, Priority,, High                                     ; 设置脚本为高优先级
#HotkeyModifierTimeout 0                             ; 修饰键粘滞问题修复（可选）

#Persistent                                                       ; 让脚本保持常驻
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 1-19
global scrollLines := 0  
WinSet, Transparent, 240, ahk_class Shell_TrayWnd			        ; 210  0-255 任务栏透明度

;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 2-29

#include *i %A_ScriptDir%\Lib\ImagePut.ahk%A_TrayMenu%.ahk
#Include *i %A_ScriptDir%\Lib\ImagePut.ahk
#Include *i %A_ScriptDir%\Lib\BTT.ahk
#Include *i %A_ScriptDir%\Lib\Gdip_All.ahk
#Include *i %A_ScriptDir%\Lib\NonNull.ahk
#Include *i %A_ScriptDir%\Lib\TrayIcon.ahk
#Include *i %A_ScriptDir%\Lib\StdOutToVar.ahk
#Include *i %A_ScriptDir%\Lib\ahk777.ahk
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 2-29

#SingleInstance Off
;MsgBox, 4096,, % A_Now
return

	OnlyOne(flag='') 
  {
  	static init:=OnlyOne('001')
  	DetectHiddenWindows, % (bak:=A_DetectHiddenWindows) ? 'On':'On'
  	mypid:=DllCall('GetCurrentProcessId')
  	flag:='Ahk_OnlyOne_Ahk<<' . flag . '>>'
  	Gui, Ahk_OnlyOne_Ahk: Show, Hide, %flag%
  	WinGet, list, List, %flag% ahk_class AutoHotkeyGUI
  	Loop, % list
  	IfWinExist, % 'ahk_id ' . list%A_Index%
  {
    	WinGet, pid, PID
    	IfEqual, pid, %mypid%, Continue
   	 WinClose, ahk_pid %pid% ahk_class AutoHotkey,, 3
    	IfWinNotExist,,, Continue
    	Process, Close, %pid%
    	WinWaitClose
  }

  	WinGet, list, List, %flag% ahk_class AutoHotkeyGUI
  	IfNotEqual, list, 1, ExitApp
  	DetectHiddenWindows, %bak%
  }

;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ   限制单进程运行    ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 3-63

;🎫🎫🎫🎫🎫🎫🎫🎫🎫🎫    基本   设置   🎫🎫🎫🎫🎫🎫🎫🎫🎫🎫🎫
;🍁🍁🍁🍁🍁🍁🍁🍁🍁🍁    复制   粘贴   🍁🍁🍁🍁🍁🍁🍁🍁🍁🍁🍁
global MyClipData
global page
*>!q:: 批量复制粘贴工具()
	#IfWinExist, 批量复制粘贴工具 ahk_class AutoHotkeyGUI
$^c::
	Clipboard:=''
	Send ^c{Ctrl Up}
	ClipWait, 3
	s:=Clipboard
	if (s='')
	ToolTip,
else
	批量复制粘贴工具(s)
	return
1::
	nume:=1
	Gosub copytt(nume)
	return
2::
	nume:=2
	Gosub copytt(nume)
	return
3::
	nume:=3
	Gosub copytt(nume)
	return
4::
	nume:=4
	Gosub copytt(nume)
	return
5::
	nume:=5
	Gosub copytt(nume)
	return
6::
	nume:=6
	Gosub copytt(nume)
	return
7::
	nume:=7
	Gosub copytt(nume)
	return
8::
	nume:=8
	Gosub copytt(nume)
	return
9::
	nume:=9
	Gosub copytt(nume)
	return
copytt(nume):
{
	i:=nume
	Clipboard:=MyClipData[i:=(page-1)*10+i]
	Send ^v
	return
}
0::
	nume1:=0
	Gosub copytt(nume1)
	return
copytt(nume1):
{
	i:=nume1
	Clipboard:=MyClipData[i:=(page-1)*10+10+i]
	Send ^v
	return
}
#IfWinExist
;-------- 下面是函数 --------
批量复制粘贴工具(s:='', Cmd:='')
{
static
  	if (Cmd='Move')
{
	if (A_GuiControl='')
	SendMessage, 0xA1, 2
	return
}
else if (Cmd='Click')
{
    	i:=SubStr(A_GuiControl, 3)
    	if (i>=1 and i<=10)
{
      	s:=MyClipData[i:=(page-1)*10+i]
      	if (s='')
        	return
      	if (!clear)
{
       	; Gui, MyClip: Hide
        	; Gui, MyClip: Show, NA
        	Clipboard:=s
        	Send ^v
        	Sleep, 200
        	return
}
      	MyClipData.RemoveAt(i)
      	if (MyClipData.length()<(page-1)*10+1)
        	page--
}
else if (i=11 and page>1)
	page--
else if (i=13 and MyClipData.length()>page*10)
	page++
else if (i=12)
      	clear:=!clear
}
else if (Cmd='' and s!='')
{
    	MyClipData.InsertAt(1,s), page:=1, clear:=0
}
 	 if !IsObject(MyClipData)
{
    MyClipData:=[], page:=1, clear:=0
    Run:=Func(A_ThisFunc).Bind('','Click')
    Gui, MyClip: Destroy
    Gui, MyClip: +AlwaysOnTop +ToolWindow +E0x08000000
    Gui, MyClip: Margin, 10, 10
    Gui, MyClip: Color, f39bdc8
    Gui, MyClip: Font, s11,c364f6b
    Loop, 13
    {
      i:=A_Index, v:=(i=11 ? '<<' : i=13 ? '>>' : '')
      j:=(i=1 ? 'w250 Left' : i=11 ? 'xm w75'
        : i=12 ? 'x+0 w100' : i=13 ? 'x+0 w75' : 'y+0 wp Left')
      Gui, MyClip: Add, Button, %j% vbt%i% Hwndid -Wrap, %v%
      GuiControl, MyClip: +g, %id%, % Run
    }
    Gui, MyClip: Show, NA, %A_ThisFunc%
    OnMessage(0x201, Func(A_ThisFunc).Bind('','Move'))
    v:=Func(A_ThisFunc).Bind('','')
    Menu, Tray, Add
    Menu, Tray, Add, %A_ThisFunc%, %v%
    Menu, Tray, Default, %A_ThisFunc%
    Menu, Tray, Click, 1
  }
  Loop, 10
  {    Menu, Tray, Click, 1

    i:=A_Index, v:=MyClipData[(page-1)*10+i]
    v:=(v='' ? v : '[' StrLen(v) '] ' SubStr(v,1,50))
    v:=RegExReplace(v, 's+', ' ')
    GuiControl, MyClip: , bt%i%, %v%
  }
  GuiControl, MyClip: , bt12, % clear ? '点选条目':'+删除条目+'
  Gui, MyClip: Show, NA
}
return
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ art+q 批量复制粘贴   ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 4-216

;#Persistent
	Copy(clipboardID) 
{
	global 
	local oldClipboard := ClipboardAll ; Save the (real) clipboard

	Clipboard := '' 
	SendInput {Ctrl Down}c{Ctrl Up}
	ClipWait, 2, 1 
if ErrorLevel 
{
	Clipboard := oldClipboard ; Restore old (real) clipboard
	return
}
	ClipboardData%clipboardID% := Clipboard
	Clipboard := oldClipboard ; Restore old (real) clipboard
}
Cut(clipboardID) 
{
	global ; All variables are global by default
	local oldClipboard := ClipboardAll ; Save the (real) clipboard
	Clipboard := '' ; Erase the clipboard first, or else ClipWait does nothing
	SendInput {Ctrl Down}x{Ctrl Up}
	ClipWait, 2, 1 ; Wait 1s until the clipboard contains any kind of data
if ErrorLevel 
{
	Clipboard := oldClipboard ; Restore old (real) clipboard
	return
}
	ClipboardData%clipboardID% := Clipboard
	Clipboard := oldClipboard ; Restore old (real) clipboard
}
Paste(clipboardID) 
{
	global
	local oldClipboard := ClipboardAll ; Save the (real) clipboard
	Clipboard := '' ; Erase the clipboard first, or else ClipWait does nothing
	Clipboard := ClipboardData%clipboardID%
	ClipWait, 2, 1 ; Wait 1s until the clipboard contains any kind of data
	SendRaw, % Clipboard ; Was having an issue with ^v
	Clipboard := oldClipboard ; Restore old (real) clipboard
}
	return
;---------------------------------------------------------------------------   copy
 >!2::Copy(1)
 >!3::Copy(2)
 >!4::Copy(3)
 >!5::Copy(4)
 >!s::Copy(5)
 >!d::Copy(6)
 >!f::Copy(7)
 ;---------------------------------------------------------------------------   paste
 >!w::Paste(1)
 >!e::Paste(2)
 >!r::Paste(3)
 >!t::Paste(4)
 >!x::Paste(5)
 >!c::Paste(6)
 >!v::Paste(7)
;-----------------------------------------------------------------------------   cut
 >!g::Cut(1)
 >!h::Cut(2)
 >!j::Cut(3)
 >!k::Cut(4)
;---------------------------------------------------------------------------   paste
 >!b::Paste(1)                                 ;-------------->! g 剪切    >! b 粘贴
 >!n::Paste(2)
 >!m::Paste(3)
 >!,::Paste(4)
;-----------------------------------------------------------------------------------
return
;ΞΞΞΞΞΞΞΞΞΞ >! 2345sdf复制  wertxcv 粘贴 ghjk剪 bnm,粘 ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 05-295

;➿➿➿➿➿➿➿➿➿➿➿➿➿➿➿➿➿➿➿➿➿➿➿➿➿➿

 >^x:: 
Clipboard := ''  ; 清空剪贴板
Send, ^c         ; 复制选中文件的路径
ClipWait, 1      ; 等待剪贴板更新

if (Clipboard) {
    FilePath := A_Desktop '\1.txt'
    FileDelete, %FilePath%  ; 先删除旧文件
    Loop, Parse, Clipboard, `n, `r  ; 按行解析剪贴板内容
    {
        SplitPath, A_LoopField, FileName  ; 获取文件名
        FileAppend, %FileName%`n, *%FilePath%, UTF-8  ; 使用 UTF-8 编码追加到文件
    }
    ;MsgBox, 文件名已保存至 %FilePath%
	Text=文件名已保存至 %FilePath%
	btt(Text,300,400,,'Style3')
	sleep, 2000
	btt()​
} else {
    MsgBox, 未选中文件！
}
return

;ΞΞΞΞΞΞΞΞΞ>^x 将选中N个文件的文件名复制到桌面的1.txt  ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 06-314

 >^c::                                              
	send, {f2}^a                                            ; ------复制文件名（包含后缀）
sleep, 10
	send, ^c{esc} 
sleep, 10
	Send, {F2}                                                ; -------------触发重命名操作
sleep, 10
	Send, ^c{esc}                                          ;-----再一次获取无后缀文件名
ClipWait, 1                                                           ; -------等待剪贴板内容准备好
	return
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ  >^c 复制文件名 有后缀和无后缀  ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 06-326

 >^v::
	send, {F2}
	sleep, 20
	send, {ctrl down}v{ctrl up}{enter}
	return
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ  >^v 对文件夹文件粘贴文件名  ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 06-333

 >^b::
if wincc_presses > 0 ; SetTimer 已经启动, 所以我们记录键击.
{
    wincc_presses += 1
    return
}
; 否则, 这是新开始系列中的首次按下. 把次数设为 1 并启动
; 计时器：
wincc_presses = 1
SetTimer, Keywincc, 300 ; 在 400 毫秒内等待更多的键击.
return

Keywincc:
SetTimer, Keywincc, off
if wincc_presses = 1 ; 此键按下了一次.
{
   Click right
sleep,200
Send, wf
Clipboard= %Clipboard%
sleep,200
send,{ctrl down}v{ctrl up}
ClipWait
send, {enter}
}
else if wincc_presses = 2 ; 此键按下了两次.
{
   Click right
sleep,200
Send, w{up 1}{enter}                                            ; 调整新建压缩包还是txt
Clipboard= %Clipboard%
sleep,200
send,{ctrl down}v{ctrl up}
ClipWait
send, {enter}
}
wincc_presses = 0
return
;ΞΞΞΞΞΞΞΞΞΞΞΞ   >^b  单 新建文件夹 双 TxT文件  名为剪贴板    ΞΞΞΞΞΞΞΞΞΞΞΞΞ 06-373

 >^z::   
send ^c
sleep,200
clipboard=%clipboard%
return
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ>^z 复制文件路径  ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 06-380

F1 & y::
send,<!{Enter}
return
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ  F1 & y 右键属性    ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 0001-653

;➿➿➿➿➿➿➿➿➿➿➿➿➿➿➿➿➿➿➿➿➿➿➿➿➿➿

NumpadEnter::
	KeyList := 'Shift|Ctrl|Alt|CapsLock|space|Appskey|win|F1|F2|F3|F4|F5|F6|F7|F8|F9' 
Loop, Parse, KeyList, |
      {
    	If GetKeystate(A_Loopfield, 'P')   ; 如果你觉得某些按键像是“卡住了”，释放以上修饰键
        	Send % '{' A_Loopfield ' Up}'
      }
; 如果你修改了桌面快捷方式或图标但图标没刷新 ⇒ 可能需要 ie4uinit.exe -ClearIconCache
Run *RunAs C:\Windows\System32\ie4uinit.exe -ClearIconCache  

sleep,1000
	reload                   ; 如果你只是修改了脚本内容，想让新内容生效 ⇒ 只要 reload
return
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ  NumpadEnter 重启脚本 ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 000005-330

;🍁🍁🍁🍁🍁🍁🍁🍁🍁🍁    复制   操作   🍁🍁🍁🍁🍁🍁🍁🍁🍁🍁🍁
;🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆    截图   操作   🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆

;ImagePutFile(Image)             ; 将图片存为文件
;ImagePutClipboard(Image)   ; 将图片存入剪贴板
;ImagePutWindow(Image)     ; 将图片显示出来
;ImageShow(Image)               ; 将图片显示出来（无标题栏）
;ImagePutDesktop(Image)     ; 将图片放在桌面壁纸前、桌面图标后的位置

insert::
Appskey & 1::
Run, nircmd  savescreenshot 'C:\Users\z\Desktop\~$currdate.yyyyMMdd$-~$currtime.HHmmss$.png'  
return                                                                   ;-----------------------截全屏
;ImagePutClipboard(ImagePutFile('A', 'C:\Users\z\Desktop\'))        ;-- 只截窗口 存剪
return
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ Appskey & 1  全屏截存桌面选格式   ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 001-331

Appskey & 2::
	Run 'D:\ahk1.0\Lib\0 tool\窗口隐藏工具\窗口隐藏工具.exe'
	Run c:\3\4\Gif123.exe
	return
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ  Appskey & 2  录屏gif    ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 003-405

Appskey & 3::
	Run 'D:\ahk1.0\Lib\0 tool\窗口隐藏工具\窗口隐藏工具.exe'
	Run c:\3\9ZDSoftScnRec\ScnRecPortable.exe
	return
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ  Appskey & 3 录屏MP4    ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 004-343

Appskey & 4::
file := ImagePutFile(clip, 'C:\Users\z\Desktop\' )
return
;ΞΞΞΞΞΞΞΞΞΞΞΞΞ  Appskey & 4  剪贴板中截图保存于desktop  ΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 005-348

Appskey & 5::                                ;---- 后台截图　4000 为间隔4秒  共运行3 次 
run, nircmd  loop 30000 2000 savescreenshot 'C:\Users\z\Desktop\aa\~$currtime.HHmm_ss$ ~$loopcount$.png'
return
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ Appskey & 5  后台间隔截图 全屏  ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 008-353

Appskey & 6::
Imageshow('a')                                                                      ;------------------截图并贴图
ImagePutFile(Image)                                           ;----------- 将图片存入剪贴板
ImagePutClipboard(ImagePutFile('A', 'C:\Users\z\Desktop'))     ; 存desktop
return
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ Appskey & 6 当前窗口 截图并贴图   ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 002-360

/*
b100(timeout = 400)                                           ; timeout 表示按键的超时时间，默认为 400 毫秒
{
    tout := timeout / 1000                                     ; 将 timeout 转换为秒，用于后面的 KeyWait
    key := RegExReplace(A_ThisHotKey, '[\*\~\$\#\+\!\^]')        ; A_ThisHotKey 是 AutoHotkey 内置变量，表示触发当前脚本的热键
    Loop                         ; 变量 key  从当前热键（A_ThisHotKey）中移除修饰符（如 *, ~, #, +, !, ^ 等）
    {
        t := A_TickCount                                          ; 记录当前的时间戳（单位：毫秒），用于计算按键按住的时长
        KeyWait %key%                                           ; 等待按键 key 被释放,   阻塞代码运行，直到用户松开按键
        Pattern .= A_TickCount - t > timeout          ; 检测按住的时间是否超过 timeout, 如果按住时长大于 timeout，则 Pattern 添加一个 1。">
<meta property="og:title" content="Ahk1.1.ahk  老版  1_1">
<meta property="og:description" content="```
#Requires AutoHotkey v1.1.36
Menu, Tray, Icon, %A_ScriptDir%\Lib\0\Library.ico  ; 自定义托盘图标
Menu, Tray, Tip, Ahk1.1                                    ; 托盘提示

#NoEnv                                                             ; 不使用旧环境变量
#SingleInstance Force                                      ; 防止重复运行
SendMode Input                                              ; 更快的发送方式
#WinActivateForce                                           ; 强制激活窗口
#ClipboardTimeout -1                                      ; 剪贴板永不超时
SetWorkingDir, %A_ScriptDir%                        ; 以脚本目录为工作目录
SetTitleMatchMode, 2                                      ; 设置窗口标题匹配为“包含”
DetectHiddenWindows, On                             ; 可以操作隐藏窗口

; 以下性能优化设置请根据需求决定是否保留
;SetBatchLines, 10ms                                        ; -1 为最大性能（高CPU）
;Process, Priority,, High                                     ; 设置脚本为高优先级
#HotkeyModifierTimeout 0                             ; 修饰键粘滞问题修复（可选）

#Persistent                                                       ; 让脚本保持常驻
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 1-19
global scrollLines := 0  
WinSet, Transparent, 240, ahk_class Shell_TrayWnd			        ; 210  0-255 任务栏透明度

;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 2-29

#include *i %A_ScriptDir%\Lib\ImagePut.ahk%A_TrayMenu%.ahk
#Include *i %A_ScriptDir%\Lib\ImagePut.ahk
#Include *i %A_ScriptDir%\Lib\BTT.ahk
#Include *i %A_ScriptDir%\Lib\Gdip_All.ahk
#Include *i %A_ScriptDir%\Lib\NonNull.ahk
#Include *i %A_ScriptDir%\Lib\TrayIcon.ahk
#Include *i %A_ScriptDir%\Lib\StdOutToVar.ahk
#Include *i %A_ScriptDir%\Lib\ahk777.ahk
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 2-29

#SingleInstance Off
;MsgBox, 4096,, % A_Now
return

	OnlyOne(flag='') 
  {
  	static init:=OnlyOne('001')
  	DetectHiddenWindows, % (bak:=A_DetectHiddenWindows) ? 'On':'On'
  	mypid:=DllCall('GetCurrentProcessId')
  	flag:='Ahk_OnlyOne_Ahk<<' . flag . '>>'
  	Gui, Ahk_OnlyOne_Ahk: Show, Hide, %flag%
  	WinGet, list, List, %flag% ahk_class AutoHotkeyGUI
  	Loop, % list
  	IfWinExist, % 'ahk_id ' . list%A_Index%
  {
    	WinGet, pid, PID
    	IfEqual, pid, %mypid%, Continue
   	 WinClose, ahk_pid %pid% ahk_class AutoHotkey,, 3
    	IfWinNotExist,,, Continue
    	Process, Close, %pid%
    	WinWaitClose
  }

  	WinGet, list, List, %flag% ahk_class AutoHotkeyGUI
  	IfNotEqual, list, 1, ExitApp
  	DetectHiddenWindows, %bak%
  }

;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ   限制单进程运行    ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 3-63

;🎫🎫🎫🎫🎫🎫🎫🎫🎫🎫    基本   设置   🎫🎫🎫🎫🎫🎫🎫🎫🎫🎫🎫
;🍁🍁🍁🍁🍁🍁🍁🍁🍁🍁    复制   粘贴   🍁🍁🍁🍁🍁🍁🍁🍁🍁🍁🍁
global MyClipData
global page
*>!q:: 批量复制粘贴工具()
	#IfWinExist, 批量复制粘贴工具 ahk_class AutoHotkeyGUI
$^c::
	Clipboard:=''
	Send ^c{Ctrl Up}
	ClipWait, 3
	s:=Clipboard
	if (s='')
	ToolTip,
else
	批量复制粘贴工具(s)
	return
1::
	nume:=1
	Gosub copytt(nume)
	return
2::
	nume:=2
	Gosub copytt(nume)
	return
3::
	nume:=3
	Gosub copytt(nume)
	return
4::
	nume:=4
	Gosub copytt(nume)
	return
5::
	nume:=5
	Gosub copytt(nume)
	return
6::
	nume:=6
	Gosub copytt(nume)
	return
7::
	nume:=7
	Gosub copytt(nume)
	return
8::
	nume:=8
	Gosub copytt(nume)
	return
9::
	nume:=9
	Gosub copytt(nume)
	return
copytt(nume):
{
	i:=nume
	Clipboard:=MyClipData[i:=(page-1)*10+i]
	Send ^v
	return
}
0::
	nume1:=0
	Gosub copytt(nume1)
	return
copytt(nume1):
{
	i:=nume1
	Clipboard:=MyClipData[i:=(page-1)*10+10+i]
	Send ^v
	return
}
#IfWinExist
;-------- 下面是函数 --------
批量复制粘贴工具(s:='', Cmd:='')
{
static
  	if (Cmd='Move')
{
	if (A_GuiControl='')
	SendMessage, 0xA1, 2
	return
}
else if (Cmd='Click')
{
    	i:=SubStr(A_GuiControl, 3)
    	if (i>=1 and i<=10)
{
      	s:=MyClipData[i:=(page-1)*10+i]
      	if (s='')
        	return
      	if (!clear)
{
       	; Gui, MyClip: Hide
        	; Gui, MyClip: Show, NA
        	Clipboard:=s
        	Send ^v
        	Sleep, 200
        	return
}
      	MyClipData.RemoveAt(i)
      	if (MyClipData.length()<(page-1)*10+1)
        	page--
}
else if (i=11 and page>1)
	page--
else if (i=13 and MyClipData.length()>page*10)
	page++
else if (i=12)
      	clear:=!clear
}
else if (Cmd='' and s!='')
{
    	MyClipData.InsertAt(1,s), page:=1, clear:=0
}
 	 if !IsObject(MyClipData)
{
    MyClipData:=[], page:=1, clear:=0
    Run:=Func(A_ThisFunc).Bind('','Click')
    Gui, MyClip: Destroy
    Gui, MyClip: +AlwaysOnTop +ToolWindow +E0x08000000
    Gui, MyClip: Margin, 10, 10
    Gui, MyClip: Color, f39bdc8
    Gui, MyClip: Font, s11,c364f6b
    Loop, 13
    {
      i:=A_Index, v:=(i=11 ? '<<' : i=13 ? '>>' : '')
      j:=(i=1 ? 'w250 Left' : i=11 ? 'xm w75'
        : i=12 ? 'x+0 w100' : i=13 ? 'x+0 w75' : 'y+0 wp Left')
      Gui, MyClip: Add, Button, %j% vbt%i% Hwndid -Wrap, %v%
      GuiControl, MyClip: +g, %id%, % Run
    }
    Gui, MyClip: Show, NA, %A_ThisFunc%
    OnMessage(0x201, Func(A_ThisFunc).Bind('','Move'))
    v:=Func(A_ThisFunc).Bind('','')
    Menu, Tray, Add
    Menu, Tray, Add, %A_ThisFunc%, %v%
    Menu, Tray, Default, %A_ThisFunc%
    Menu, Tray, Click, 1
  }
  Loop, 10
  {    Menu, Tray, Click, 1

    i:=A_Index, v:=MyClipData[(page-1)*10+i]
    v:=(v='' ? v : '[' StrLen(v) '] ' SubStr(v,1,50))
    v:=RegExReplace(v, 's+', ' ')
    GuiControl, MyClip: , bt%i%, %v%
  }
  GuiControl, MyClip: , bt12, % clear ? '点选条目':'+删除条目+'
  Gui, MyClip: Show, NA
}
return
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ art+q 批量复制粘贴   ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 4-216

;#Persistent
	Copy(clipboardID) 
{
	global 
	local oldClipboard := ClipboardAll ; Save the (real) clipboard

	Clipboard := '' 
	SendInput {Ctrl Down}c{Ctrl Up}
	ClipWait, 2, 1 
if ErrorLevel 
{
	Clipboard := oldClipboard ; Restore old (real) clipboard
	return
}
	ClipboardData%clipboardID% := Clipboard
	Clipboard := oldClipboard ; Restore old (real) clipboard
}
Cut(clipboardID) 
{
	global ; All variables are global by default
	local oldClipboard := ClipboardAll ; Save the (real) clipboard
	Clipboard := '' ; Erase the clipboard first, or else ClipWait does nothing
	SendInput {Ctrl Down}x{Ctrl Up}
	ClipWait, 2, 1 ; Wait 1s until the clipboard contains any kind of data
if ErrorLevel 
{
	Clipboard := oldClipboard ; Restore old (real) clipboard
	return
}
	ClipboardData%clipboardID% := Clipboard
	Clipboard := oldClipboard ; Restore old (real) clipboard
}
Paste(clipboardID) 
{
	global
	local oldClipboard := ClipboardAll ; Save the (real) clipboard
	Clipboard := '' ; Erase the clipboard first, or else ClipWait does nothing
	Clipboard := ClipboardData%clipboardID%
	ClipWait, 2, 1 ; Wait 1s until the clipboard contains any kind of data
	SendRaw, % Clipboard ; Was having an issue with ^v
	Clipboard := oldClipboard ; Restore old (real) clipboard
}
	return
;---------------------------------------------------------------------------   copy
 >!2::Copy(1)
 >!3::Copy(2)
 >!4::Copy(3)
 >!5::Copy(4)
 >!s::Copy(5)
 >!d::Copy(6)
 >!f::Copy(7)
 ;---------------------------------------------------------------------------   paste
 >!w::Paste(1)
 >!e::Paste(2)
 >!r::Paste(3)
 >!t::Paste(4)
 >!x::Paste(5)
 >!c::Paste(6)
 >!v::Paste(7)
;-----------------------------------------------------------------------------   cut
 >!g::Cut(1)
 >!h::Cut(2)
 >!j::Cut(3)
 >!k::Cut(4)
;---------------------------------------------------------------------------   paste
 >!b::Paste(1)                                 ;-------------->! g 剪切    >! b 粘贴
 >!n::Paste(2)
 >!m::Paste(3)
 >!,::Paste(4)
;-----------------------------------------------------------------------------------
return
;ΞΞΞΞΞΞΞΞΞΞ >! 2345sdf复制  wertxcv 粘贴 ghjk剪 bnm,粘 ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 05-295

;➿➿➿➿➿➿➿➿➿➿➿➿➿➿➿➿➿➿➿➿➿➿➿➿➿➿

 >^x:: 
Clipboard := ''  ; 清空剪贴板
Send, ^c         ; 复制选中文件的路径
ClipWait, 1      ; 等待剪贴板更新

if (Clipboard) {
    FilePath := A_Desktop '\1.txt'
    FileDelete, %FilePath%  ; 先删除旧文件
    Loop, Parse, Clipboard, `n, `r  ; 按行解析剪贴板内容
    {
        SplitPath, A_LoopField, FileName  ; 获取文件名
        FileAppend, %FileName%`n, *%FilePath%, UTF-8  ; 使用 UTF-8 编码追加到文件
    }
    ;MsgBox, 文件名已保存至 %FilePath%
	Text=文件名已保存至 %FilePath%
	btt(Text,300,400,,'Style3')
	sleep, 2000
	btt()​
} else {
    MsgBox, 未选中文件！
}
return

;ΞΞΞΞΞΞΞΞΞ>^x 将选中N个文件的文件名复制到桌面的1.txt  ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 06-314

 >^c::                                              
	send, {f2}^a                                            ; ------复制文件名（包含后缀）
sleep, 10
	send, ^c{esc} 
sleep, 10
	Send, {F2}                                                ; -------------触发重命名操作
sleep, 10
	Send, ^c{esc}                                          ;-----再一次获取无后缀文件名
ClipWait, 1                                                           ; -------等待剪贴板内容准备好
	return
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ  >^c 复制文件名 有后缀和无后缀  ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 06-326

 >^v::
	send, {F2}
	sleep, 20
	send, {ctrl down}v{ctrl up}{enter}
	return
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ  >^v 对文件夹文件粘贴文件名  ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 06-333

 >^b::
if wincc_presses > 0 ; SetTimer 已经启动, 所以我们记录键击.
{
    wincc_presses += 1
    return
}
; 否则, 这是新开始系列中的首次按下. 把次数设为 1 并启动
; 计时器：
wincc_presses = 1
SetTimer, Keywincc, 300 ; 在 400 毫秒内等待更多的键击.
return

Keywincc:
SetTimer, Keywincc, off
if wincc_presses = 1 ; 此键按下了一次.
{
   Click right
sleep,200
Send, wf
Clipboard= %Clipboard%
sleep,200
send,{ctrl down}v{ctrl up}
ClipWait
send, {enter}
}
else if wincc_presses = 2 ; 此键按下了两次.
{
   Click right
sleep,200
Send, w{up 1}{enter}                                            ; 调整新建压缩包还是txt
Clipboard= %Clipboard%
sleep,200
send,{ctrl down}v{ctrl up}
ClipWait
send, {enter}
}
wincc_presses = 0
return
;ΞΞΞΞΞΞΞΞΞΞΞΞ   >^b  单 新建文件夹 双 TxT文件  名为剪贴板    ΞΞΞΞΞΞΞΞΞΞΞΞΞ 06-373

 >^z::   
send ^c
sleep,200
clipboard=%clipboard%
return
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ>^z 复制文件路径  ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 06-380

F1 & y::
send,<!{Enter}
return
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ  F1 & y 右键属性    ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 0001-653

;➿➿➿➿➿➿➿➿➿➿➿➿➿➿➿➿➿➿➿➿➿➿➿➿➿➿

NumpadEnter::
	KeyList := 'Shift|Ctrl|Alt|CapsLock|space|Appskey|win|F1|F2|F3|F4|F5|F6|F7|F8|F9' 
Loop, Parse, KeyList, |
      {
    	If GetKeystate(A_Loopfield, 'P')   ; 如果你觉得某些按键像是“卡住了”，释放以上修饰键
        	Send % '{' A_Loopfield ' Up}'
      }
; 如果你修改了桌面快捷方式或图标但图标没刷新 ⇒ 可能需要 ie4uinit.exe -ClearIconCache
Run *RunAs C:\Windows\System32\ie4uinit.exe -ClearIconCache  

sleep,1000
	reload                   ; 如果你只是修改了脚本内容，想让新内容生效 ⇒ 只要 reload
return
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ  NumpadEnter 重启脚本 ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 000005-330

;🍁🍁🍁🍁🍁🍁🍁🍁🍁🍁    复制   操作   🍁🍁🍁🍁🍁🍁🍁🍁🍁🍁🍁
;🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆    截图   操作   🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆

;ImagePutFile(Image)             ; 将图片存为文件
;ImagePutClipboard(Image)   ; 将图片存入剪贴板
;ImagePutWindow(Image)     ; 将图片显示出来
;ImageShow(Image)               ; 将图片显示出来（无标题栏）
;ImagePutDesktop(Image)     ; 将图片放在桌面壁纸前、桌面图标后的位置

insert::
Appskey & 1::
Run, nircmd  savescreenshot 'C:\Users\z\Desktop\~$currdate.yyyyMMdd$-~$currtime.HHmmss$.png'  
return                                                                   ;-----------------------截全屏
;ImagePutClipboard(ImagePutFile('A', 'C:\Users\z\Desktop\'))        ;-- 只截窗口 存剪
return
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ Appskey & 1  全屏截存桌面选格式   ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 001-331

Appskey & 2::
	Run 'D:\ahk1.0\Lib\0 tool\窗口隐藏工具\窗口隐藏工具.exe'
	Run c:\3\4\Gif123.exe
	return
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ  Appskey & 2  录屏gif    ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 003-405

Appskey & 3::
	Run 'D:\ahk1.0\Lib\0 tool\窗口隐藏工具\窗口隐藏工具.exe'
	Run c:\3\9ZDSoftScnRec\ScnRecPortable.exe
	return
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ  Appskey & 3 录屏MP4    ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 004-343

Appskey & 4::
file := ImagePutFile(clip, 'C:\Users\z\Desktop\' )
return
;ΞΞΞΞΞΞΞΞΞΞΞΞΞ  Appskey & 4  剪贴板中截图保存于desktop  ΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 005-348

Appskey & 5::                                ;---- 后台截图　4000 为间隔4秒  共运行3 次 
run, nircmd  loop 30000 2000 savescreenshot 'C:\Users\z\Desktop\aa\~$currtime.HHmm_ss$ ~$loopcount$.png'
return
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ Appskey & 5  后台间隔截图 全屏  ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 008-353

Appskey & 6::
Imageshow('a')                                                                      ;------------------截图并贴图
ImagePutFile(Image)                                           ;----------- 将图片存入剪贴板
ImagePutClipboard(ImagePutFile('A', 'C:\Users\z\Desktop'))     ; 存desktop
return
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ Appskey & 6 当前窗口 截图并贴图   ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 002-360

/*
b100(timeout = 400)                                           ; timeout 表示按键的超时时间，默认为 400 毫秒
{
    tout := timeout / 1000                                     ; 将 timeout 转换为秒，用于后面的 KeyWait
    key := RegExReplace(A_ThisHotKey, '[\*\~\$\#\+\!\^]')        ; A_ThisHotKey 是 AutoHotkey 内置变量，表示触发当前脚本的热键
    Loop                         ; 变量 key  从当前热键（A_ThisHotKey）中移除修饰符（如 *, ~, #, +, !, ^ 等）
    {
        t := A_TickCount                                          ; 记录当前的时间戳（单位：毫秒），用于计算按键按住的时长
        KeyWait %key%                                           ; 等待按键 key 被释放,   阻塞代码运行，直到用户松开按键
        Pattern .= A_TickCount - t > timeout          ; 检测按住的时间是否超过 timeout, 如果按住时长大于 timeout，则 Pattern 添加一个 1。">
<meta property="og:type" content="article">
<meta property="og:url" content="https://z.zcr4.ip-ddns.com/post/Ahk1.1.ahk%20%20-lao-ban-%20%201_1.html">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zb9678/img@main/im8/05.03:15:58:50.png">
<title>Ahk1.1.ahk  老版  1_1</title>



</head>
<style>
body{box-sizing: border-box;min-width: 200px;max-width: 900px;margin: 20px auto;padding: 45px;font-size: 16px;font-family: sans-serif;line-height: 1.25;}
#header{display:flex;padding-bottom:8px;border-bottom: 1px solid var(--borderColor-muted, var(--color-border-muted));margin-bottom: 16px;}
#footer {margin-top:64px; text-align: center;font-size: small;}

</style>

<style>
.postTitle{margin: auto 0;font-size:40px;font-weight:bold;}
.title-right{display:flex;margin:auto 0 0 auto;}
.title-right .circle{padding: 14px 16px;margin-right:8px;}
#postBody{border-bottom: 1px solid var(--color-border-default);padding-bottom:36px;}
#postBody hr{height:2px;}
#cmButton{height:48px;margin-top:48px;}
#comments{margin-top:64px;}
.g-emoji{font-size:24px;}
@media (max-width: 600px) {
    body {padding: 8px;}
    .postTitle{font-size:24px;}
}
.copy-feedback {
    display: none;
    position: absolute;
    top: 10px;
    right: 50px;
    color: var(--color-fg-on-emphasis);
    background-color: var(--color-fg-muted);
    border-radius: 3px;
    padding: 5px 8px;
    font-size: 12px;
}
</style>




<body>
    <div id="header">
<h1 class="postTitle">Ahk1.1.ahk  老版  1_1</h1>
<div class="title-right">
    <a href="https://z.zcr4.ip-ddns.com" id="buttonHome" class="btn btn-invisible circle" title="首页">
        <svg class="octicon" width="16" height="16">
            <path id="pathHome" fill-rule="evenodd"></path>
        </svg>
    </a>
    
    <a href="https://github.com/zcr07/zcr7.github.io/issues/43" target="_blank" class="btn btn-invisible circle" title="Issue">
        <svg class="octicon" width="16" height="16">
            <path id="pathIssue" fill-rule="evenodd"></path>
        </svg>
    </a>
    

    <a class="btn btn-invisible circle" onclick="modeSwitch();" title="切换主题">
        <svg class="octicon" width="16" height="16" >
            <path id="themeSwitch" fill-rule="evenodd"></path>
        </svg>
    </a>

</div>
</div>
    <div id="content">
<div class="markdown-body" id="postBody"><pre class="notranslate"><code class="notranslate">#Requires AutoHotkey v1.1.36
Menu, Tray, Icon, %A_ScriptDir%\Lib\0\Library.ico  ; 自定义托盘图标
Menu, Tray, Tip, Ahk1.1                                    ; 托盘提示

#NoEnv                                                             ; 不使用旧环境变量
#SingleInstance Force                                      ; 防止重复运行
SendMode Input                                              ; 更快的发送方式
#WinActivateForce                                           ; 强制激活窗口
#ClipboardTimeout -1                                      ; 剪贴板永不超时
SetWorkingDir, %A_ScriptDir%                        ; 以脚本目录为工作目录
SetTitleMatchMode, 2                                      ; 设置窗口标题匹配为“包含”
DetectHiddenWindows, On                             ; 可以操作隐藏窗口

; 以下性能优化设置请根据需求决定是否保留
;SetBatchLines, 10ms                                        ; -1 为最大性能（高CPU）
;Process, Priority,, High                                     ; 设置脚本为高优先级
#HotkeyModifierTimeout 0                             ; 修饰键粘滞问题修复（可选）

#Persistent                                                       ; 让脚本保持常驻
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 1-19
global scrollLines := 0  
WinSet, Transparent, 240, ahk_class Shell_TrayWnd			        ; 210  0-255 任务栏透明度

;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 2-29

#include *i %A_ScriptDir%\Lib\ImagePut.ahk%A_TrayMenu%.ahk
#Include *i %A_ScriptDir%\Lib\ImagePut.ahk
#Include *i %A_ScriptDir%\Lib\BTT.ahk
#Include *i %A_ScriptDir%\Lib\Gdip_All.ahk
#Include *i %A_ScriptDir%\Lib\NonNull.ahk
#Include *i %A_ScriptDir%\Lib\TrayIcon.ahk
#Include *i %A_ScriptDir%\Lib\StdOutToVar.ahk
#Include *i %A_ScriptDir%\Lib\ahk777.ahk
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 2-29

#SingleInstance Off
;MsgBox, 4096,, % A_Now
return

	OnlyOne(flag="") 
  {
  	static init:=OnlyOne("001")
  	DetectHiddenWindows, % (bak:=A_DetectHiddenWindows) ? "On":"On"
  	mypid:=DllCall("GetCurrentProcessId")
  	flag:="Ahk_OnlyOne_Ahk&lt;&lt;" . flag . "&gt;&gt;"
  	Gui, Ahk_OnlyOne_Ahk: Show, Hide, %flag%
  	WinGet, list, List, %flag% ahk_class AutoHotkeyGUI
  	Loop, % list
  	IfWinExist, % "ahk_id " . list%A_Index%
  {
    	WinGet, pid, PID
    	IfEqual, pid, %mypid%, Continue
   	 WinClose, ahk_pid %pid% ahk_class AutoHotkey,, 3
    	IfWinNotExist,,, Continue
    	Process, Close, %pid%
    	WinWaitClose
  }

  	WinGet, list, List, %flag% ahk_class AutoHotkeyGUI
  	IfNotEqual, list, 1, ExitApp
  	DetectHiddenWindows, %bak%
  }

;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ   限制单进程运行    ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 3-63

;🎫🎫🎫🎫🎫🎫🎫🎫🎫🎫    基本   设置   🎫🎫🎫🎫🎫🎫🎫🎫🎫🎫🎫
;🍁🍁🍁🍁🍁🍁🍁🍁🍁🍁    复制   粘贴   🍁🍁🍁🍁🍁🍁🍁🍁🍁🍁🍁
global MyClipData
global page
*&gt;!q:: 批量复制粘贴工具()
	#IfWinExist, 批量复制粘贴工具 ahk_class AutoHotkeyGUI
$^c::
	Clipboard:=""
	Send ^c{Ctrl Up}
	ClipWait, 3
	s:=Clipboard
	if (s="")
	ToolTip,
else
	批量复制粘贴工具(s)
	return
1::
	nume:=1
	Gosub copytt(nume)
	return
2::
	nume:=2
	Gosub copytt(nume)
	return
3::
	nume:=3
	Gosub copytt(nume)
	return
4::
	nume:=4
	Gosub copytt(nume)
	return
5::
	nume:=5
	Gosub copytt(nume)
	return
6::
	nume:=6
	Gosub copytt(nume)
	return
7::
	nume:=7
	Gosub copytt(nume)
	return
8::
	nume:=8
	Gosub copytt(nume)
	return
9::
	nume:=9
	Gosub copytt(nume)
	return
copytt(nume):
{
	i:=nume
	Clipboard:=MyClipData[i:=(page-1)*10+i]
	Send ^v
	return
}
0::
	nume1:=0
	Gosub copytt(nume1)
	return
copytt(nume1):
{
	i:=nume1
	Clipboard:=MyClipData[i:=(page-1)*10+10+i]
	Send ^v
	return
}
#IfWinExist
;-------- 下面是函数 --------
批量复制粘贴工具(s:="", Cmd:="")
{
static
  	if (Cmd="Move")
{
	if (A_GuiControl="")
	SendMessage, 0xA1, 2
	return
}
else if (Cmd="Click")
{
    	i:=SubStr(A_GuiControl, 3)
    	if (i&gt;=1 and i&lt;=10)
{
      	s:=MyClipData[i:=(page-1)*10+i]
      	if (s="")
        	return
      	if (!clear)
{
       	; Gui, MyClip: Hide
        	; Gui, MyClip: Show, NA
        	Clipboard:=s
        	Send ^v
        	Sleep, 200
        	return
}
      	MyClipData.RemoveAt(i)
      	if (MyClipData.length()&lt;(page-1)*10+1)
        	page--
}
else if (i=11 and page&gt;1)
	page--
else if (i=13 and MyClipData.length()&gt;page*10)
	page++
else if (i=12)
      	clear:=!clear
}
else if (Cmd="" and s!="")
{
    	MyClipData.InsertAt(1,s), page:=1, clear:=0
}
 	 if !IsObject(MyClipData)
{
    MyClipData:=[], page:=1, clear:=0
    Run:=Func(A_ThisFunc).Bind("","Click")
    Gui, MyClip: Destroy
    Gui, MyClip: +AlwaysOnTop +ToolWindow +E0x08000000
    Gui, MyClip: Margin, 10, 10
    Gui, MyClip: Color, f39bdc8
    Gui, MyClip: Font, s11,c364f6b
    Loop, 13
    {
      i:=A_Index, v:=(i=11 ? "&lt;&lt;" : i=13 ? "&gt;&gt;" : "")
      j:=(i=1 ? "w250 Left" : i=11 ? "xm w75"
        : i=12 ? "x+0 w100" : i=13 ? "x+0 w75" : "y+0 wp Left")
      Gui, MyClip: Add, Button, %j% vbt%i% Hwndid -Wrap, %v%
      GuiControl, MyClip: +g, %id%, % Run
    }
    Gui, MyClip: Show, NA, %A_ThisFunc%
    OnMessage(0x201, Func(A_ThisFunc).Bind("","Move"))
    v:=Func(A_ThisFunc).Bind("","")
    Menu, Tray, Add
    Menu, Tray, Add, %A_ThisFunc%, %v%
    Menu, Tray, Default, %A_ThisFunc%
    Menu, Tray, Click, 1
  }
  Loop, 10
  {    Menu, Tray, Click, 1

    i:=A_Index, v:=MyClipData[(page-1)*10+i]
    v:=(v="" ? v : "[" StrLen(v) "] " SubStr(v,1,50))
    v:=RegExReplace(v, "s+", " ")
    GuiControl, MyClip: , bt%i%, %v%
  }
  GuiControl, MyClip: , bt12, % clear ? "点选条目":"+删除条目+"
  Gui, MyClip: Show, NA
}
return
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ art+q 批量复制粘贴   ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 4-216

;#Persistent
	Copy(clipboardID) 
{
	global 
	local oldClipboard := ClipboardAll ; Save the (real) clipboard

	Clipboard := "" 
	SendInput {Ctrl Down}c{Ctrl Up}
	ClipWait, 2, 1 
if ErrorLevel 
{
	Clipboard := oldClipboard ; Restore old (real) clipboard
	return
}
	ClipboardData%clipboardID% := Clipboard
	Clipboard := oldClipboard ; Restore old (real) clipboard
}
Cut(clipboardID) 
{
	global ; All variables are global by default
	local oldClipboard := ClipboardAll ; Save the (real) clipboard
	Clipboard := "" ; Erase the clipboard first, or else ClipWait does nothing
	SendInput {Ctrl Down}x{Ctrl Up}
	ClipWait, 2, 1 ; Wait 1s until the clipboard contains any kind of data
if ErrorLevel 
{
	Clipboard := oldClipboard ; Restore old (real) clipboard
	return
}
	ClipboardData%clipboardID% := Clipboard
	Clipboard := oldClipboard ; Restore old (real) clipboard
}
Paste(clipboardID) 
{
	global
	local oldClipboard := ClipboardAll ; Save the (real) clipboard
	Clipboard := "" ; Erase the clipboard first, or else ClipWait does nothing
	Clipboard := ClipboardData%clipboardID%
	ClipWait, 2, 1 ; Wait 1s until the clipboard contains any kind of data
	SendRaw, % Clipboard ; Was having an issue with ^v
	Clipboard := oldClipboard ; Restore old (real) clipboard
}
	return
;---------------------------------------------------------------------------   copy
 &gt;!2::Copy(1)
 &gt;!3::Copy(2)
 &gt;!4::Copy(3)
 &gt;!5::Copy(4)
 &gt;!s::Copy(5)
 &gt;!d::Copy(6)
 &gt;!f::Copy(7)
 ;---------------------------------------------------------------------------   paste
 &gt;!w::Paste(1)
 &gt;!e::Paste(2)
 &gt;!r::Paste(3)
 &gt;!t::Paste(4)
 &gt;!x::Paste(5)
 &gt;!c::Paste(6)
 &gt;!v::Paste(7)
;-----------------------------------------------------------------------------   cut
 &gt;!g::Cut(1)
 &gt;!h::Cut(2)
 &gt;!j::Cut(3)
 &gt;!k::Cut(4)
;---------------------------------------------------------------------------   paste
 &gt;!b::Paste(1)                                 ;--------------&gt;! g 剪切    &gt;! b 粘贴
 &gt;!n::Paste(2)
 &gt;!m::Paste(3)
 &gt;!,::Paste(4)
;-----------------------------------------------------------------------------------
return
;ΞΞΞΞΞΞΞΞΞΞ &gt;! 2345sdf复制  wertxcv 粘贴 ghjk剪 bnm,粘 ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 05-295

;➿➿➿➿➿➿➿➿➿➿➿➿➿➿➿➿➿➿➿➿➿➿➿➿➿➿

 &gt;^x:: 
Clipboard := ""  ; 清空剪贴板
Send, ^c         ; 复制选中文件的路径
ClipWait, 1      ; 等待剪贴板更新

if (Clipboard) {
    FilePath := A_Desktop "\1.txt"
    FileDelete, %FilePath%  ; 先删除旧文件
    Loop, Parse, Clipboard, `n, `r  ; 按行解析剪贴板内容
    {
        SplitPath, A_LoopField, FileName  ; 获取文件名
        FileAppend, %FileName%`n, *%FilePath%, UTF-8  ; 使用 UTF-8 编码追加到文件
    }
    ;MsgBox, 文件名已保存至 %FilePath%
	Text=文件名已保存至 %FilePath%
	btt(Text,300,400,,"Style3")
	sleep, 2000
	btt()​
} else {
    MsgBox, 未选中文件！
}
return

;ΞΞΞΞΞΞΞΞΞ&gt;^x 将选中N个文件的文件名复制到桌面的1.txt  ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 06-314

 &gt;^c::                                              
	send, {f2}^a                                            ; ------复制文件名（包含后缀）
sleep, 10
	send, ^c{esc} 
sleep, 10
	Send, {F2}                                                ; -------------触发重命名操作
sleep, 10
	Send, ^c{esc}                                          ;-----再一次获取无后缀文件名
ClipWait, 1                                                           ; -------等待剪贴板内容准备好
	return
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ  &gt;^c 复制文件名 有后缀和无后缀  ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 06-326

 &gt;^v::
	send, {F2}
	sleep, 20
	send, {ctrl down}v{ctrl up}{enter}
	return
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ  &gt;^v 对文件夹文件粘贴文件名  ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 06-333

 &gt;^b::
if wincc_presses &gt; 0 ; SetTimer 已经启动, 所以我们记录键击.
{
    wincc_presses += 1
    return
}
; 否则, 这是新开始系列中的首次按下. 把次数设为 1 并启动
; 计时器：
wincc_presses = 1
SetTimer, Keywincc, 300 ; 在 400 毫秒内等待更多的键击.
return

Keywincc:
SetTimer, Keywincc, off
if wincc_presses = 1 ; 此键按下了一次.
{
   Click right
sleep,200
Send, wf
Clipboard= %Clipboard%
sleep,200
send,{ctrl down}v{ctrl up}
ClipWait
send, {enter}
}
else if wincc_presses = 2 ; 此键按下了两次.
{
   Click right
sleep,200
Send, w{up 1}{enter}                                            ; 调整新建压缩包还是txt
Clipboard= %Clipboard%
sleep,200
send,{ctrl down}v{ctrl up}
ClipWait
send, {enter}
}
wincc_presses = 0
return
;ΞΞΞΞΞΞΞΞΞΞΞΞ   &gt;^b  单 新建文件夹 双 TxT文件  名为剪贴板    ΞΞΞΞΞΞΞΞΞΞΞΞΞ 06-373

 &gt;^z::   
send ^c
sleep,200
clipboard=%clipboard%
return
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ&gt;^z 复制文件路径  ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 06-380

F1 &amp; y::
send,&lt;!{Enter}
return
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ  F1 &amp; y 右键属性    ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 0001-653

;➿➿➿➿➿➿➿➿➿➿➿➿➿➿➿➿➿➿➿➿➿➿➿➿➿➿

NumpadEnter::
	KeyList := "Shift|Ctrl|Alt|CapsLock|space|Appskey|win|F1|F2|F3|F4|F5|F6|F7|F8|F9" 
Loop, Parse, KeyList, |
      {
    	If GetKeystate(A_Loopfield, "P")   ; 如果你觉得某些按键像是“卡住了”，释放以上修饰键
        	Send % "{" A_Loopfield " Up}"
      }
; 如果你修改了桌面快捷方式或图标但图标没刷新 ⇒ 可能需要 ie4uinit.exe -ClearIconCache
Run *RunAs C:\Windows\System32\ie4uinit.exe -ClearIconCache  

sleep,1000
	reload                   ; 如果你只是修改了脚本内容，想让新内容生效 ⇒ 只要 reload
return
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ  NumpadEnter 重启脚本 ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 000005-330

;🍁🍁🍁🍁🍁🍁🍁🍁🍁🍁    复制   操作   🍁🍁🍁🍁🍁🍁🍁🍁🍁🍁🍁
;🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆    截图   操作   🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆

;ImagePutFile(Image)             ; 将图片存为文件
;ImagePutClipboard(Image)   ; 将图片存入剪贴板
;ImagePutWindow(Image)     ; 将图片显示出来
;ImageShow(Image)               ; 将图片显示出来（无标题栏）
;ImagePutDesktop(Image)     ; 将图片放在桌面壁纸前、桌面图标后的位置

insert::
Appskey &amp; 1::
Run, nircmd  savescreenshot "C:\Users\z\Desktop\~$currdate.yyyyMMdd$-~$currtime.HHmmss$.png"  
return                                                                   ;-----------------------截全屏
;ImagePutClipboard(ImagePutFile("A", "C:\Users\z\Desktop\"))        ;-- 只截窗口 存剪
return
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ Appskey &amp; 1  全屏截存桌面选格式   ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 001-331

Appskey &amp; 2::
	Run "D:\ahk1.0\Lib\0 tool\窗口隐藏工具\窗口隐藏工具.exe"
	Run c:\3\4\Gif123.exe
	return
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ  Appskey &amp; 2  录屏gif    ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 003-405

Appskey &amp; 3::
	Run "D:\ahk1.0\Lib\0 tool\窗口隐藏工具\窗口隐藏工具.exe"
	Run c:\3\9ZDSoftScnRec\ScnRecPortable.exe
	return
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ  Appskey &amp; 3 录屏MP4    ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 004-343

Appskey &amp; 4::
file := ImagePutFile(clip, "C:\Users\z\Desktop\" )
return
;ΞΞΞΞΞΞΞΞΞΞΞΞΞ  Appskey &amp; 4  剪贴板中截图保存于desktop  ΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 005-348

Appskey &amp; 5::                                ;---- 后台截图　4000 为间隔4秒  共运行3 次 
run, nircmd  loop 30000 2000 savescreenshot "C:\Users\z\Desktop\aa\~$currtime.HHmm_ss$ ~$loopcount$.png"
return
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ Appskey &amp; 5  后台间隔截图 全屏  ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 008-353

Appskey &amp; 6::
Imageshow("a")                                                                      ;------------------截图并贴图
ImagePutFile(Image)                                           ;----------- 将图片存入剪贴板
ImagePutClipboard(ImagePutFile("A", "C:\Users\z\Desktop"))     ; 存desktop
return
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ Appskey &amp; 6 当前窗口 截图并贴图   ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 002-360

/*
b100(timeout = 400)                                           ; timeout 表示按键的超时时间，默认为 400 毫秒
{
    tout := timeout / 1000                                     ; 将 timeout 转换为秒，用于后面的 KeyWait
    key := RegExReplace(A_ThisHotKey, "[\*\~\$\#\+\!\^]")        ; A_ThisHotKey 是 AutoHotkey 内置变量，表示触发当前脚本的热键
    Loop                         ; 变量 key  从当前热键（A_ThisHotKey）中移除修饰符（如 *, ~, #, +, !, ^ 等）
    {
        t := A_TickCount                                          ; 记录当前的时间戳（单位：毫秒），用于计算按键按住的时长
        KeyWait %key%                                           ; 等待按键 key 被释放,   阻塞代码运行，直到用户松开按键
        Pattern .= A_TickCount - t &gt; timeout          ; 检测按住的时间是否超过 timeout, 如果按住时长大于 timeout，则 Pattern 添加一个 1。否则，Pattern 添加一个 0,   A_TickCount - t 计算按住时长, Pattern 是一个字符串，记录按键的长短按模式
        KeyWait %key%, DT%tout%      ; 再次等待按键按下，但设置了超时 tout（秒）如果按键在超时时间内未被按下，ErrorLevel 会被置为 1       
        If (ErrorLevel)                              ; 如果检测到超时（ErrorLevel = 1），退出循环并返回 Pattern
            Return Pattern                        ; 返回 Pattern，它是一个字符串 每次按键按住的模式（0 或 1）都会依次记录到 Pattern 中
    }
}
*/

+Esc:: 
    p := b100()
    If (p = "0")                  ; 用户触发 b106(), 开始检测当前热键的按键模式
    {
        Run, c:\3\9 FSCapture97\FSCapture.exe, , min
        Sleep, 800
        SendInput, !+x ; 开始截图
        ; 等待编辑器窗口打开
        WinWait, ahk_class TMainWin.UnicodeClass, , 20 ; 等待 5 秒，超时则跳过
        IfWinExist, ahk_class TMainWin.UnicodeClass
        {
            WinActivate ; 激活编辑器窗口
            Sleep, 500  ; 确保窗口完全激活
            SendInput, &lt;^s
        }
    }
    If (p = "00")
    {
        Process, Close, FSCapture.exe
    }
return

;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ  +Esc::  单击FSCapture双击退出   ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 006-452

#SingleInstance force
isRunning := false                                                ;---- 用于跟踪脚本是否在运行
timerRunning := false                                          ;-- 用于跟踪定时器是否在运行

 &gt;^Esc::                                             
    	Process, Exist, Umi-OCR.exe                   ; --------检查程序是否在运行
    	if (ErrorLevel) 
{
        	Process, Close, Umi-OCR.exe                 ;---- 如果程序在运行则关闭它
        	isRunning := false                                  ;----------- 更新状态为未运行
        	SetTimer, AutoCloseUmi-OCR, Off        ;------------------ 关闭定时器
        	timerRunning := false                            ;------------- 更新定时器状态
}
else 
{
        	Run, "D:\ahk1.0\Lib\0 tool\Umi-OCR\Umi-OCR.exe", , hide
        	Sleep, 2200
        	Send, +^!z                                             ;-------------截图快捷键 +^!z  
       	isRunning := true                                   ;--------  更新状态为正在运行

        	if (!timerRunning)                                   ;----------- 如果定时器未运行
       {                                          
            	SetTimer, AutoCloseUmi-OCR, -20000  ; --------------------------设置一个20秒的单次定时器
            	timerRunning := true                             ;---- 更新定时器状态为运行中
       }
}
return
;----------------------------------------------------------------------------定时器
AutoCloseUmi-OCR:
    	Process, Close, Umi-OCR.exe                ;------------自动关闭截图软件
    	isRunning := false                                  ;----------- 更新状态为未运行
    	timerRunning := false                            ;---- 更新定时器状态为未运行
	return
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ  &gt;^Esc  Umi-OCR.exe    ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 007-487

&lt;!esc::                                      ;------------------------------------ OCR 或截图
    	send, !j                        ;----------------------------------暂时关闭 VPN
	Click, 0, 875                        ;---------------------------防止截图时显示光标等
    	run "D:\ahk1.0\Lib\0 tool\SGScreencapture\screencapture.exe"
    	SetTimer, ReEnableVPN, -14000            ;----------------------------- 设置一个14秒的单次定时器
	return
	ReEnableVPN:
    	send, !u                       ;---------------------------------- 重新启用 VPN
	return
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ &lt;!esc  截图 OCR  ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 012-518

$&lt;^Esc::     
	run "D:\ahk1.0\Lib\0 tool\ScreenCapture\ScreenCapture.exe"
return
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ  &lt;^Esc  截图    ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 21-408

AppsKey &amp; Esc::         
	Run, C:\3\9金山截图王\kscrcap.exe,, , PID
	Process, Priority, %PID%, High
	Sleep, 1000
	return
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ Appskey &amp; Esc   金山截图    ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 21-408

$+#s::                                        ;-------------------系统自带加了一个保存在桌面
	clipboard =
	clipboard = clipboardALL
	Send, {PrintScreen}
sleep,5000
	file := ImagePutFile(clip, "C:\oneD\OneDrive\desktop\" )
return
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ  +#s  截图  剪贴板 desktop   ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 011-507

#esc::	                                                               ;   框选OCR
send, !j
sleep, 10
send, ^]
sleep, 9000
send, !u
return
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ #esc  关闭Vpn Ocr 再打开Vpn ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 14-305

;#SingleInstance Force
;#NoEnv
displayNum := 0
visibleState := true

F9 &amp; 9::
	pasteToScreen(){
	if DllCall("IsClipboardFormatAvailable", "UInt", 1)
	displayText(Clipboard)
	If DllCall("IsClipboardFormatAvailable", "UInt", 2)
{
	if DllCall("OpenClipboard", "uint", 0) 
{
	hBitmap := DllCall("GetClipboardData", "uint", 2)
	DllCall("CloseClipboard")
}
	displayImg(hBitmap)
}
	if DllCall("IsClipboardFormatAvailable", "UInt", 15){
	imgFile := Clipboard
	if(hBitmap := LoadPicture(imgFile))
	displayImg(hBitmap)
}
}
	displayText(text)
{
	global
Gui, New, +hwndpasteText%displayNum% -Caption +AlwaysOnTop +ToolWindow -DPIScale
	local textHnd := pasteText%displayNum%
	Gui, Margin, 10, 10
	Gui, Font, s16
	Gui, Add, Text,, % text
	OnMessage(0x201, "move_Win")
	OnMessage(0x203, "close_Win")
	Gui, Show,, pasteToScreen_text
	transparency%textHnd% := 100
	displayNum++
}
	displayImg(hBitmap)
{
	global
Gui, New, +hwndpasteImg%displayNum% -Caption +AlwaysOnTop +ToolWindow -DPIScale
	local imgHnd := pasteImg%displayNum%
	Gui, Margin, 0, 0
	Gui, Add, Picture, Hwndimg%imgHnd%, % "HBITMAP:*" hBitmap
	OnMessage(0x201, "move_Win")
	OnMessage(0x203, "close_Win")
	Gui, Show,, pasteToScreen_img
	local img := img%imgHnd%
ControlGetPos,,, width%imgHnd%, height%imgHnd%,, ahk_id %img%
	scale%imgHnd% := 100
	transparency%imgHnd% := 100
	displayNum++
}
	move_Win()
{
	PostMessage, 0xA1, 2
}
	close_Win()
{
	id := WinExist("A")
	transparency%id% := ""
	scale%id% := ""
	width%id% := ""
	height%id% := ""
	Gui, Destroy
}

return
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ    F9+9 贴图   ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 013-588
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ    Shift+鼠标滚动   改变粘贴的透明度   ΞΞΞΞΞΞΞΞΞΞ 014-588
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ    鼠标滚轮改变贴图大小 双击关闭   ΞΞΞΞΞΞΞΞΞΞΞΞΞ015-588

F9 &amp; 0::
	toggleVisibleState()
{
	global visibleState
	if(visibleState){
	WinGet, id, List, pasteToScreen
	Loop, %id%
{
	this_id := id%A_Index%
	WinHide, ahk_id %this_id%
}
	visibleState := false
} 
	else 
{
	DetectHiddenWindows, On
	WinGet, id, List, pasteToScreen
	Loop, %id%
{
	this_id := id%A_Index%
	WinShow, ahk_id %this_id%
}
	DetectHiddenWindows, Off
	visibleState := true
}
}
	return
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ    F9+0 隐藏或显示所有粘贴    ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 016-619

F9 &amp; -::
	destroyAllPaste()
{
	WinGet, id, List, pasteToScreen
	Loop, %id%
{
	this_id := id%A_Index%
	SendMessage, 0x203,,,, ahk_id %this_id%
}
}
	return
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ    F9+- 关闭贴图    ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 017-632

F9 &amp; =::
	FileSelectFile, imgFile, 3, C:\oneD\OneDrive\desktop\
	hBitmap := LoadPicture(imgFile)
	displayImg(hBitmap)
	return
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ    F9+= 打开图并设置为贴图   ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 018-639

F9 &amp; 8::
	Imageshow({image: %clipboardAll%, scale: ["auto", 600]})  ;长自动，宽600
	;Imageshow({image: %clipboardAll%, scale: 2.25})   ; 放大到2.25倍
	return
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ  F9 &amp; 8 剪贴板贴图 放大到1.25倍   ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 019-645

;🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆    截图   操作   🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆
;🎟🎟🎟🎟🎟🎟🎟🎟🎟🎟    显隐   操作   🎟🎟🎟🎟🎟🎟🎟🎟🎟🎟🎟

F5 &amp; 1::
	HideShowTaskbar()
{
   	static SW_HIDE := 0, SW_SHOWNA := 8, SPI_SETWORKAREA := 0x2F
   	DetectHiddenWindows, On
   	hTB := WinExist("ahk_class Shell_TrayWnd")
   	WinGetPos,,,, H
hBT := WinExist("ahk_class Button ahk_exe Explorer.EXE")  ; for Windows 7
   	b := DllCall("IsWindowVisible", "Ptr", hTB)
   	for k, v in [hTB, hBT]
( v &amp;&amp; DllCall("ShowWindow", "Ptr", v, "Int", b ? SW_HIDE : SW_SHOWNA) )
   	VarSetCapacity(RECT, 16, 0)
   	NumPut(A_ScreenWidth, RECT, 8)
   	NumPut(A_ScreenHeight - !b*H, RECT, 12, "UInt")
DllCall("SystemParametersInfo", "UInt", SPI_SETWORKAREA, "UInt", 0, "Ptr", &amp;RECT, "UInt", 0)
   	WinGet, List, List
	Loop % List
{
	WinGet, res, MinMax, % "ahk_id" . List%A_Index%
	if (res = 1)
WinMove, % "ahk_id" . List%A_Index%,, 0, 0, A_ScreenWidth, A_ScreenHeight - !b*H
}
}
	return
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ    F5 &amp; 1  隐藏任务栏   ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 0002-679

F5 &amp; 2::
	ControlGet, q, Hwnd,, SysListView321, ahk_class Progman
If q =
	ControlGet, q, Hwnd,, SysListView321, ahk_class WorkerW
If DllCall("IsWindowVisible", UInt, q)
	WinHide, ahk_id %q%
Else
	WinShow, ahk_id %q%
Return
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ    F5 &amp; 2  隐藏桌面图标   ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 0003-690

toggle := false           ; ---------------------定义一个变量来跟踪状态

F5 &amp; 3::

if (toggle)             ;检查当前状态，如果为 true，则显示；如果为 false，则隐藏。
{
        	run, nircmd.exe win show class progman                    ; 显示桌面图标
} 
	else 
{
        	run, nircmd.exe win hide class progman                      ; 隐藏桌面图标
}

toggle := !toggle              ;---切换状态使得下次按下 F5.. 时能够执行相反的操作。
return
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ  F5 &amp; 3  隐.显桌面   ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 0004-706

F5 &amp; y::          ;;显示文件
RegRead,value,HKEY_CURRENT_USER,Software\Microsoft\Windows\CurrentVersion\Explorer\Advanced\, Hidden
	If(value=1)
	value = 2
	Else
	value = 1
RegWrite, REG_DWORD, HKEY_CURRENT_USER,Software\Microsoft\Windows\CurrentVersion\Explorer\Advanced\, Hidden, %Value%
RegWrite, REG_DWORD, HKEY_CURRENT_USER,Software\Microsoft\Windows\CurrentVersion\Explorer\Advanced\, ShowSuperHidden, %Value%-1
	PostMessage,0x111,0x7103,0,SHELLDLL_DefView1,A
	return

F5 &amp; k::           ;;显示文件扩展名
RegRead,Value,HKEY_CURRENT_USER,Software\Microsoft\Windows\CurrentVersion\Explorer\Advanced\,HideFileExt
	If(value=0)
	value = 1
	Else
	value = 0
RegWrite, REG_DWORD,HKEY_CURRENT_USER,Software\Microsoft\Windows\CurrentVersion\Explorer\Advanced\,HideFileExt, %Value%
	PostMessage,0x111,0x7103,0,SHELLDLL_DefView1,A
	return
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ   F5 &amp; k 显示扩展名 F5 &amp; y 显隐文件   ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 0005-728

F5 &amp; 4::
; 设置注册表路径和值名称
regPath := "HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\Advanced"
valueName := "IconsOnly"

; 读取当前的 IconsOnly 值
RegRead, currentValue, %regPath%, %valueName%

; 如果读取失败（值不存在），则将值初始化为 0
if (ErrorLevel)
    currentValue := 0

; 切换值：如果当前值是 0 则设置为 1，否则设置为 0
newValue := (currentValue = 0) ? 1 : 0

; 写入新值到注册表
RegWrite, REG_DWORD, %regPath%, %valueName%, %newValue%

 ; 刷新资源管理器以应用更改
;send, ^r
; 使用 COM 对象刷新桌面和文件资源管理器窗口
for window in ComObjCreate("Shell.Application").Windows
{
    if (window.FullName != "")  ; 检查是否是有效的资源管理器窗口
        window.Refresh()
}
return
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ  F5 &amp; 4  缩略图   ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 0006-757

F5 &amp; 5::
Send, &lt;!p
return
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ F5 &amp; 5 显示预览窗格  ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 0007-762

F5 &amp; 6::
	WinGetActiveTitle, Title
	Title := StrReplace(Title, "Ξ置顶 Ξ")
	ID := WinExist("A")
	WinGet, ExStyle, ExStyle, ahk_id %ID%
	If (ExStyle &amp; 0x8)
{
	WinSet,TopMost,,A
	WinSetTitle, , ,Ξ OFF Ξ
 	SoundPlay, D:\ahk1.0\Lib\0\y2253.mp3
}
	Else
{
	WinSet,TopMost,,A
	WinSetTitle, , ,Ξ 置顶 Ξ
   	SoundPlay, D:\ahk1.0\Lib\0\2.mp3
}
return
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ    F5 &amp; 6  窗口置顶    ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 0008-782

;🍁🍁🍁🍁🍁🍁🍁🍁🍁🍁    显隐   操作   🍁🍁🍁🍁🍁🍁🍁🍁🍁🍁🍁
;🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆    打开   操作   🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆

F5 &amp; 9::
	Imageshow("D:\ahk1.0\1\1.png")
	return
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ  F5 &amp; 9  快捷键目录   ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 00002-801

F5 &amp; 0::
	Imageshow("D:\ahk1.0\1\2.png")
	return
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ  F5 &amp; 0  快捷键目录   ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 00003-806
 
F5 &amp; -::
	Imageshow("D:\ahk1.0\1\7.png")
	return
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ  F5 &amp; 0  快捷键目录   ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 00003-806
 
F5 &amp; +::
	Imageshow("D:\ahk1.0\1\5.png")
	return
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ  F5 &amp; 0  五笔键图示   ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 00003-806

F1 &amp; k::
{
; 保存当前剪贴板内容
   	clipboardBackup := ClipboardAll
	Clipboard := ""  ; 清空剪贴板
; 复制选中的快捷方式路径
    	Send, ^c
    	ClipWait, 1
if ErrorLevel 
{
        	MsgBox, 未能复制到剪贴板。
        	Clipboard := clipboardBackup  ; 还原剪贴板内容
        	return
}
; 获取快捷方式的目标路径
    	FileGetShortcut, %Clipboard%, shortcutPath
if (shortcutPath != "") {
; 使用资源管理器打开并选中目标文件
        	Run, explorer.exe /select`, %shortcutPath%
;select`：是用于资源管理器中打开包含指定文件的文件夹并选中该文件的参数。
;  , :         逗号用于分隔命令和参数。在这里，它将 select 命令与后面的参数分开。
} 
	else 
{
        	MsgBox, 当前剪贴板内容不是有效的快捷方式。
}
	; 还原剪贴板内容
    	Clipboard := clipboardBackup
    	return
}
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ  F1 &amp; k 打开快捷方式的文件夹    ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 00004-838

^+z:: 
	WinGet, processID, PID, A                      ;--获取当前活动窗口的进程ID
WinGet, exePath, ProcessPath, ahk_pid %processID%    ; 获取可执行文件路径 
	SplitPath, exePath, , fileDir            ; 提取文件夹路径
	Run, %fileDir%            ; 打开文件夹
 	return
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ  ^+z 打开当前软件的文件夹   ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 00005-846

#SingleInstance force                                                          ; 强制加载新的脚本
isRunning := false                  ; 状态变量: isRunning 用于跟踪脚本是否正在运行
F1 &amp; v::
    Process, Exist, v2rayN.exe                                      ; 检查程序是否已经在运行
    if (ErrorLevel)                 ;根据 ErrorLevel 的值来决定是关闭程序还是启动程序
    {
                                                                            ; 如果程序正在运行，则关闭它
        Process, Close, v2rayN.exe
        isRunning := false                                                        ; 更新状态为未运行
    } 
    else 
    {
                                                                        ; 如果程序没有在运行，则启动它
        Run, D:\ahk1.0\Lib\0 tool\v2rayN-With-Core\v2rayN.exe , , min 
        isRunning := true                                                     ; 更新状态为正在运行
    }
return
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ    F1 &amp; v 打开 v2rayN.exe ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 00007-894

#SingleInstance force                                                          ; 强制加载新的脚本
isRunning := false                  ; 状态变量: isRunning 用于跟踪脚本是否正在运行
F1 &amp; x::
    Process, Exist, karing.exe                                      ; 检查程序是否已经在运行
    if (ErrorLevel)                 ;根据 ErrorLevel 的值来决定是关闭程序还是启动程序
    {
                                                                            ; 如果程序正在运行，则关闭它
        Process, Close, karing.exe
        isRunning := false                                                        ; 更新状态为未运行
    } 
    else 
    {
                                                                        ; 如果程序没有在运行，则启动它
        ;Run, D:\ahk1.0\Lib\0 tool\karing_1.0.39.527_windows_x64\karing.exe, , min 
        Run, D:\ahk1.0\Lib\0 tool\karing_1.1.0.574_windows_x64\karing.exe, , min 
        isRunning := true                                                     ; 更新状态为正在运行
    }
return
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ    F1 &amp; x 打开 karing.exe  ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 00007-894

#SingleInstance force                                                          ; 强制加载新的脚本
isRunning := false                  ; 状态变量: isRunning 用于跟踪脚本是否正在运行
F1 &amp; z::
    Process, Exist, Mihomo Party.exe                                    ; 检查程序是否已经在运行
    if (ErrorLevel)                 ;根据 ErrorLevel 的值来决定是关闭程序还是启动程序
    {
                                                                            ; 如果程序正在运行，则关闭它
        Process, Close, Mihomo Party.exe
        isRunning := false                                                        ; 更新状态为未运行
    } 
    else 
    {
                                                                        ; 如果程序没有在运行，则启动它
        Run, D:\ahk1.0\Lib\0 tool\mihomo-party-windows-1.7.1-x64-portable\Mihomo Party.exe, , min 
        isRunning := true                                                     ; 更新状态为正在运行
    }
return
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ  F1 &amp; z 打开 Mihomo Party.exe  ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 00007-894

#SingleInstance force                                                          ; 强制加载新的脚本
isRunning := false                  ; 状态变量: isRunning 用于跟踪脚本是否正在运行
F1 &amp; b::
    Process, Exist, Hiddify.exe                                     ; 检查程序是否已经在运行
    if (ErrorLevel)                 ;根据 ErrorLevel 的值来决定是关闭程序还是启动程序
    {
                                                                            ; 如果程序正在运行，则关闭它
        Process, Close, Hiddify.exe
        isRunning := false                                                        ; 更新状态为未运行
    } 
    else 
    {
                                                                        ; 如果程序没有在运行，则启动它
        Run, D:\ahk1.0\Lib\0 tool\Hiddify-Windows-Portable-x64\Hiddify.exe, , min 
        isRunning := true                                                     ; 更新状态为正在运行
    }
return
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ  F1 &amp; b 打开 Hiddify.exe    ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 00007-894

#SingleInstance force                                                          ; 强制加载新的脚本
isRunning := false                  ; 状态变量: isRunning 用于跟踪脚本是否正在运行
F1 &amp; n::
    Process, Exist, GUI.for.SingBox.exe                                     ; 检查程序是否已经在运行
    if (ErrorLevel)                 ;根据 ErrorLevel 的值来决定是关闭程序还是启动程序
    {
                                                                            ; 如果程序正在运行，则关闭它
        Process, Close, GUI.for.SingBox.exe
        isRunning := false                                                        ; 更新状态为未运行
    } 
    else 
    {
                                                                        ; 如果程序没有在运行，则启动它
        Run, D:\ahk1.0\Lib\0 tool\GUI.for.SingBox-windows-amd64\GUI.for.SingBox.exe, , min 
        isRunning := true                                                     ; 更新状态为正在运行
    }
return
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ  F1 &amp; n 打开 GUI.for.SingBox.exe  ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 00007-894

#SingleInstance force                                                          ; 强制加载新的脚本
isRunning := false                  ; 状态变量: isRunning 用于跟踪脚本是否正在运行
F1 &amp; m::
    Process, Exist, subs-check.win.gui.exe                   ; 检查程序是否已经在运行
    if (ErrorLevel)                 ;根据 ErrorLevel 的值来决定是关闭程序还是启动程序
    {
                                                                            ; 如果程序正在运行，则关闭它
        Process, Close, subs-check.win.gui.exe
        isRunning := false                                                        ; 更新状态为未运行
    } 
    else 
    {
                                                                        ; 如果程序没有在运行，则启动它
        Run, D:\ahk1.0\Lib\0 tool\SubsCheck_Win_GUI\subs-check.win.gui.exe     ;, , min 
        isRunning := true                                                     ; 更新状态为正在运行
    }
return
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ  F1 &amp; m 打开 subs-check.win.gui.exe  ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 00007-1030

#SingleInstance force ;----------- 强制加载新的脚本
isRunning := false ; 状态变量: isRunning 用于跟踪脚本是否正在运行

F9 &amp; [::
if (isRunning)
{
; 1.如果脚本已经在运行，则关闭它
Name := "SnoMouse.ahk" ;------ 指定要退出的脚本名称
DetectHiddenWindows, On ;------ 启用对隐藏窗口的检测
SetTitleMatchMode, 2 ; 设置标题匹配模式

   	WinClose, %Name% ahk_class AutoHotkey
    isRunning := false 			                        ;-----------更新状态为未运行
	} 

  else {
   					 ; 2.如果脚本没有在运行，则启动它
    	Run D:\ahk1.0\Lib\SnoMouse.ahk
    isRunning := true                                         ;---------更新状态为正在运行
 }
return
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ  F9 &amp; [ 启动或退出 SnoMouse ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 00009-917

#SingleInstance force      ; 强制加载新的脚本
isRunning := false         ; 状态变量: isRunning 用于跟踪脚本是否正在运行。
 &gt;!Esc::
    Process, Exist, ZoomIt64.exe       ; 检查程序是否已经在运行
    if (ErrorLevel)      ;根据 ErrorLevel 的值来决定是关闭程序还是启动程序，而不再依赖于 isRunning 状态变量。这可以避免因状态更新不及时而导致的需要按两次热键的问题。
    {
                                                                          ; 如果程序正在运行，则关闭它
        Process, Close, ZoomIt64.exe
        isRunning := false     ; 更新状态为未运行
    } 
    else 
    {
                                                                      ; 如果程序没有在运行，则启动它
        Run, D:\ahk1.0\Lib\0 tool\ZoomIt64\ZoomIt64.exe
sleep, 1000
send, ^2
        isRunning := true      ; 更新状态为正在运行
    }
return
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ   &gt;!Esc 启动 / 关闭  ZoomIt64.exe   ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 00010-938

 CoordMode, Mouse, Client  ; 设置坐标模式为客户端
F1 &amp; c::
	Run "C:\Program Files\Google\Chrome\Application\chrome.exe" ; --new-window, , max
	WinWait, ahk_exe chrome.exe, , 5         ;---------------- 最多等待 5 秒
	;Run, C:\3\v2rayN-With-Core\v2rayN.exe , , min
	;Run, D:\ahk1.0\Lib\0 tool\karing_1.0.39.527_windows_x64\karing.exe , , min
/*
Send, ^t
Sleep, 300
Send, ^+{Del}                                                       ; 执行 Ctrl + Shift + Delete
Sleep, 1000

; 定义点击次数和位置
clickCount := 1  ; 设置需要点击的次数
xPos := 978      ; 点击的 X 坐标（根据 Client 坐标调整）
yPos := 617       ; 点击的 Y 坐标（根据 Client 坐标调整）

; 循环执行 ControlClick
Loop, %clickCount%
{
    ControlClick, x%xPos% y%yPos%, ahk_class Chrome_WidgetWin_1
    Sleep, 300  ; 每次点击后暂停300毫秒，确保应用程序有时间处理请求
}
send, ^w
*/
return
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ  F1 &amp; C  打开 chrome     ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 00011-969

F1 &amp; t::
	Run "D:\ahk1.0\Lib\0 tool\Tor Browser\Browser\firefox.exe" --new-window, , max
	;Run, D:\ahk1.0\Lib\0 tool\pinginfoview\PingInfoView.exe
return
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ  F1 &amp; t  打开 Tor Browser  ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 00011-912

F5 &amp; b::
	Run "C:\Program Files\Borderfree\firefox.exe" --new-window, , max
	;Run, D:\ahk1.0\Lib\0 tool\pinginfoview\PingInfoView.exe
return
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ  F1 &amp; t  打开 Borderfree  ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 00011-1025

F5 &amp; 8::
	o=D:\ahk1.0\Lib\0 tool\EmEditor-24.5.3-x64\EmEditor.exe

	1=D:\ahk1.0\Lib\0 tool\picgo-croe\config.toml
	2=C:\Users\z\.picgo\config.json
	3=D:\ahk1.0\Lib\ahk777.ahk
	4=D:\ahk1.0\Ahk1.1.ahk

	Run,%o% "%1%" "%2%" "%3%" "%4%"
return
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ   F5 &amp; 8    EmEditor 打开4文件   ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 00006-856

;#Persistent                     ;确保脚本常驻：保证脚本不因长时间未使用而自动退出。
Rctrl &amp; 2::
    KeyWait, Rctrl, D  ; 确保释放 Rctrl 键后再执行操作

    ; 检查 EmEditor.exe 是否已存在
    IfWinNotExist, ahk_exe EmEditor.exe
    {
        Run "D:\ahk1.0\Lib\0 tool\EmEditor-24.5.3-x64\EmEditor.exe"
        ;Run "C:\0　　tool\EmEditor\EmEditor.exe"
        WinWait, ahk_exe EmEditor.exe, , 5  ; 最多等待 5 秒
    }
    Else IfWinNotActive, ahk_exe EmEditor.exe
    {
        WinActivate  ; 激活窗口
    }
    Else
    {
        ; 检查窗口是否已最小化
        IfWinExist, ahk_exe EmEditor.exe
        {
            WinGet, MinimizedState, MinMax, ahk_exe EmEditor.exe
            if (MinimizedState = -1)  ; 如果窗口已最小化
                WinRestore  ; 还原窗口
            else
                WinMinimize  ; 否则最小化窗口
        }
    }
Return

;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ  Rctrl &amp; 2   打开 EmEditor  ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 00012-999

Rctrl &amp; 3::
    KeyWait, Rctrl, D  ; 确保释放 Rctrl 键后再执行操作

    IfWinNotExist, ahk_class CabinetWClass
    {
        Run, "C:\Windows\explorer.exe"
        WinWait, ahk_class CabinetWClass, , 5  ; 最多等待 5 秒
        If !ErrorLevel  ; 确保窗口确实已存在
        {
            Sleep, 100  ; 短暂延时确保稳定
            WinActivate
        }
    }
    Else IfWinNotActive, ahk_class CabinetWClass
    {
        WinActivate
    }
    Else
    {
        WinMinimize
    }
Return

;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ  Rctrl &amp; 3  打开 资源处理器   ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 00013-1026

CoordMode, Mouse, Window
Rctrl &amp; 4::
WeChat:="ahk_class WeChatMainWndForPC"
WeChat_path:="C:\Program Files\Tencent\WeChat\WeChat.exe" ，max

if ProcessExist("WeChat.exe")=0
{
	Run, %WeChat_path%
WinWait, ahk_class WeChatLoginWndForPC
}
else
{
	WinGet,wxhwnd,ID,%WeChat%
	if strlen(wxhwnd)=0
	{
		winshow,%WeChat%
		winactivate,%WeChat%
	}
	else
	{
		winhide,%WeChat%
	}
}
return

ProcessExist(exe){		   ;一个自定义函数,根据自定义函数的返回值作为#if成立依据原GetPID
	Process, Exist,% exe
	return ErrorLevel
}
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ  Rctrl &amp; 4  打开 微信    ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 00014-1062

;#Persistent
F5 &amp; c::
    KeyWait, F5, D  ; 确保释放 Rctrl 键后再执行操作

    IfWinNotExist, ahk_exe Cursor.exe
    {
        Run "C:\Users\z\AppData\Local\Programs\cursor\Cursor.exe"
        WinWait, ahk_exe Cursor.exe, , 5  ; 最多等待 5 秒
    }
    Else IfWinNotActive, ahk_exe Cursor.exe
    {
        WinActivate  ; 激活窗口
    }
    Else
    {
        ; 检查窗口是否已最小化
        IfWinExist, ahk_exe Cursor.exe
        {
            WinGet, MinimizedState, MinMax, ahk_exe Cursor.exe
            if (MinimizedState = -1)  ; 如果窗口已最小化
                WinRestore  ; 还原窗口
            else
                WinMinimize  ; 否则最小化窗口
        }
    }
Return

;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ    F5 &amp; c  Cursor.exe     ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 00015-1068

;🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆    打开   操作   🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆
; 💢⭐💢⭐💢⭐💢⭐💢⭐💢⭐    杂类   操作   ⭐💢⭐💢⭐💢⭐💢⭐💢⭐💢⭐💢

F4 &amp; F5::AltTab
return
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ       F4 &amp; F5  AltTab    ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 000001-1074

F6 &amp; d::
	Clip(Format("{:" GetNextCaseFormat() "}", Clip()), true)
	GetNextCaseFormat()
{
   	static i := 0, Formats := ["U", "L", "T"]
   	return Formats[++i &gt; 3 ? i := 1 : i]
}
	Clip(Text="", Reselect="")
{
	Static BackUpClip, Stored, LastClip
If (A_ThisLabel = A_ThisFunc) 
{
	If (Clipboard == LastClip)
	Clipboard := BackUpClip
	BackUpClip := LastClip := Stored := ""
} 
	Else 
{
If !Stored {
	Stored := True
	BackUpClip := ClipboardAll ; ClipboardAll must be on its own line
} 
	Else
	SetTimer, %A_ThisFunc%, Off
	LongCopy := A_TickCount, Clipboard := "", LongCopy -= A_TickCount ; LongCopy gauges the amount of time it takes to empty the clipboard which can predict how long the subsequent clipwait will need
	If (Text = "") 
{
	SendInput, ^c
	ClipWait, LongCopy ? 0.6 : 0.2, True
} 
	Else 
{
	Clipboard := LastClip := Text
	ClipWait, 10
	SendInput, ^v
}
	SetTimer, %A_ThisFunc%, -700
Sleep 20 ; Short sleep in case Clip() is followed by more keystrokes such as {Enter}
If (Text = "")
	Return LastClip := Clipboard
	Else If ReSelect and ((ReSelect = True) or (StrLen(Text) &lt; 3000))
	SendInput, % "{Shift Down}{Left " StrLen(StrReplace(Text, "`r")) "}{Shift Up}"
}
	Return
	Clip:
	Return Clip()
}
	return
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ  F6 &amp; d 大小写 首字母大写  ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 000002-1124

F5 &amp; s::
run D:\ahk1.0\Lib\diskeys.ahk
return
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ F5 &amp; s  锁键盘鼠标  ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 000003-1129

~Shift &amp; Wheelup::
; 透明度调整，增加。
WinGet, Transparent, Transparent,A
If (Transparent="")
    Transparent=255
    Transparent_New:=Transparent+15    ;透明度增加速度。
    If (Transparent_New &gt; 254)
                    Transparent_New =255
    WinSet,Transparent,%Transparent_New%,A

    tooltip now: ▲%Transparent_New%`nmae: __%Transparent%  ;查看当前透明度（操作之后的）。
    ;sleep 1500
    SetTimer, RemoveToolTip_transparent_Lwin__2016.09.20, 1500  ;设置统一的这个格式，label在最后。
return

~Shift &amp; WheelDown::
;透明度调整，减少。
WinGet, Transparent, Transparent,A
If (Transparent="")
    Transparent=255
    Transparent_New:=Transparent-15  ;透明度减少速度。
    ;msgbox,Transparent_New=%Transparent_New%
            If (Transparent_New &lt; 30)    ;最小透明度限制。
                    Transparent_New = 30
    WinSet,Transparent,%Transparent_New%,A
    tooltip now: ▲%Transparent_New%`nmae: __%Transparent%  ;查看当前透明度（操作之后的）。
    ;sleep 1500
    SetTimer, RemoveToolTip_transparent_Lwin__2016.09.20, 1500  ;设置统一的这个格式，label在最后。
return
;设置shift &amp;Mbutton直接恢复透明度到255。

shift &amp; Mbutton::
WinGet, Transparent, Transparent,A
WinSet,Transparent,255,A
tooltip ▲Restored ;查看当前透明度（操作之后的）。
;sleep 1500
SetTimer, RemoveToolTip_transparent_Lwin__2016.09.20, 1500  ;设置统一的这个格式，label在最后。
return

removetooltip_transparent_Lwin__2016.09.20:     ;LABEL
tooltip
SetTimer, RemoveToolTip_transparent_Lwin__2016.09.20, Off
return
;---------------shift+滚轮down +10透明度
;--------------------------------shift+滚轮up -10透明度
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ  shift+中键按下 复原   ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 000004-1176

+appskey::
send {Tab}
loop,4
SoundBeep, 12000, 20
return
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ  +appskey   Tab  ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 000006-1187

&lt;^!z::
send, ^y
return
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ  &lt;^!z   撤消    ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 000007-1192

;#NoEnv
   ;SendMode Input
   ;SetWorkingDir %A_ScriptDir%
	MoveCycle(Add)
{
	static StepsInCycle = 2                        ;--------------在2种状态间切换
	static SizeCycle = 0
	SizeCycle := Mod(SizeCycle + Add, StepsInCycle)
	if (SizeCycle &lt; 0)
	{
		SizeCycle := SizeCycle + StepsInCycle
	}
	if (Add = 111) {
		SizeCycle = 1
	}
	else if (Add = 222) {
		SizeCycle = 2
	}
	else if (Add = 333) {
		SizeCycle = 3
	}

	if (SizeCycle = 0) {
		MoveWindow(50, 50)
	}
	else if (SizeCycle = 1) {
		MoveWindow(0, 50)
	}
	else if (SizeCycle = 2) {
		MoveWindow(0, 100)
	}
	else if (SizeCycle = 3) {
		MoveWindow(15, 70)

	}
	else if (SizeCycle = 4) {
		MoveWindow(20, 80)
	}
else if (SizeCycle = 5)
	{
		MoveWindow(10, 80)
	}
}

MoveWindow(XP, WP)
{
	; Get current Window
	WinGetActiveTitle, WinTitle
	WinGetPos, X, Y, WinWidth, WinHeight, %WinTitle%

	; Get Taskbar height
	WinGetPos,,, tbW, tbH, ahk_class Shell_TrayWnd

	; Calculate new position and size
	XNew := (A_ScreenWidth * XP / 100)
	WNew := (A_ScreenWidth * WP / 100)
	HNew := (A_ScreenHeight - tbH)
	TopNew := 2

	; MsgBox, %XNew% - %WNew% ; DEBUG
	WinRestore, %WinTitle%
	WinMove, %WinTitle%,, %XNew%, %TopNew%, %WNew%, %HNew%
}

&lt;!z::
	MoveCycle(-1)
return
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ &lt;!z  窗口左半，右半切换   ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 000008-1261

;#NoEnv
  ; SendMode Input
  ; SetWorkingDir %A_ScriptDir%
	MoveCycle2(Add)
{
	static StepsInCycle2 = 2                        ;--------------------------------------在2种状态间切换
	static SizeCycle2 = 0
	SizeCycle2 := Mod(SizeCycle2 + Add, StepsInCycle2)
	if (SizeCycle2 &lt; 0)
	{
		SizeCycle2 := SizeCycle2 + StepsInCycle2
	}
	if (Add = 111) {
		SizeCycle2 = 1
	}
	else if (Add = 222) {
		SizeCycle2 = 2
	}
	else if (Add = 333) {
		SizeCycle2 = 3
	}

	if (SizeCycle2 = 0) {
		MoveWindow2(0, 100)
	}
	else if (SizeCycle2 = 1) {
		MoveWindow2(15, 70)
	}
	else if (SizeCycle2 = 2) {
		MoveWindow2(0, 100)
	}
	else if (SizeCycle2 = 3) {
		MoveWindow2(15, 70)

	}
	else if (SizeCycle2 = 4) {
		MoveWindow2(10, 80)
	}
else if (SizeCycle2 = 5) {
		MoveWindow2(0, 80)
	}
}

MoveWindow2(XP, WP)
{
	; Get current Window2
	WinGetActiveTitle, WinTitle
	WinGetPos, X, Y, WinWidth, WinHeight, %WinTitle%

	; Get Taskbar height
	WinGetPos,,, tbW, tbH, ahk_class Shell_TrayWnd

	; Calculate new position and size
	XNew := (A_ScreenWidth * XP / 100)
	WNew := (A_ScreenWidth * WP / 100)
	HNew := (A_ScreenHeight - tbH  / 1.3)
	TopNew := 1

	; MsgBox, %XNew% - %WNew% ; DEBUG
	WinRestore, %WinTitle%
	WinMove, %WinTitle%,, %XNew%, %TopNew%, %WNew%, %HNew%
}

	&lt;!x::
	MoveCycle2(-1)
	return
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ  &lt; !x  切换窗口  70%·····100%    ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 000009-1329

/*
; 如果当前脚本没有以管理员权限运行，并且命令行参数中没有 /restart 选项，
; 则以管理员权限重新启动脚本，并添加 /restart 选项。这样可以确保脚本以管理员权限运行，同时避免无限循环重启。
;if !A_IsAdmin &amp;&amp; !RegExMatch(_:=DllCall("GetCommandLineW", "Str"), " /restart(?!\S)")
    ;RunWait % "*RunAs " RegExReplace(_, "^\"".*?\""\K|^\S*\K", " /restart")
F5 &amp; 7::
run D:\ahk1.0\Lib\二维码.ahk
send, ^c
;sleep, 800
;run D:\ahk1.0\Lib\二维码.ahk
;sleep, 200
;send, {enter}
return
*/

F5 &amp; 7::
run D:\ahk1.0\Lib\二维码.ahk
send, ^c
return
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ  F5 &amp; 7  二维码  ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 000010-1320

!LButton::    ;-- 【Win+鼠标左键】任意移动窗口位置
#LButton::    ;-- 【Win+鼠标右键】任意调整窗口大小
Critical
CoordMode, Mouse
MouseGetPos, x1, y1, id
IfWinNotExist, ahk_id %id%
  return
WinGet, flag, MinMax    ;-- 不操作最大化的窗口
if flag=1
  return
SetWinDelay, 20
WinGetPos, x2, y2, w2, h2
While GetKeyState(SubStr(A_ThisLabel,2),"P")
{
  MouseGetPos, x3, y3
  if A_ThisLabel = !LButton
    WinMove, x3-x1+x2, y3-y1+y2
  else
    WinMove,,,,, x3-x1+w2, y3-y1+h2
}
return
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ  !+左键 移窗口 #+左键 调窗口大小   ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 000011-1363

    ; Windows messages to monitor
    msg_WM_WTSSESSION_CHANGE = 0x2b1
    msg_WM_POWERBROADCAST    = 0x218

    ; Registry key and value to store the state of the mouse buttons
    reg_KeyName = HKEY_CURRENT_USER\SessionInformation
    reg_ValueName = LeftHandedMouse

    ; Set taskbar tray icon
    Menu, Tray, Icon, shell32.dll, 44 ; Gold star icon
    Menu, Tray, Tip, Swap Mouse Buttons

    ; Initialize
    ; Create an invisile window which is registered to receive WTSRegisterSessionNotification notifications (for lock and unlock messages)
    ; and RegisterPowerSettingNotification notifications (for suspend and wake-up messages)
    Gui,+LastFound
    hwnd:=WinExist()

    ; Register the window for WTSRegisterSessionNotification notifications in order to receive the WM_WTSSESSION_CHANGE messages
    DllCall("Wtsapi32.dll\WTSRegisterSessionNotification","UInt",hwnd,"UInt",0)

    ; Register the window for RegisterPowerSettingNotification notification in order to receive the WM_POWERBROADCAST messages
    ; hHandle is set to the hidden window
    ; PowerSettingGuid is set to GUID_SYSTEM_AWAYMODE
    ; Flags is 0 (DEVICE_NOTIFY_WINDOW_HANDLE) to register for notifications sent using WM_POWERBROADCAST messages
    DllCall("User32.dll\RegisterPowerSettingNotification",hwnd,"98a7f580-01f7-48aa-9c0f-44352c29e5C0",0)

    ; Register function to recieive the WM_WTSSESSION_CHANGE messages
    OnMessage(msg_WM_WTSSESSION_CHANGE,"f_WM_Monitor")

    ; Register functino to receive the WM_POWERBROADCAST messages
    OnMessage(msg_WM_POWERBROADCAST,"f_WM_Monitor")

    ; Set the mouse to the last known state
    RegRead, buttonState, %reg_KeyName%, %reg_ValueName%
    if (ErrorLevel) ; Reistry value not found
    {
        buttonState := DllCall("user32.dll\SwapMouseButton", "UInt", 1) ; Set left-handed mouse
        if buttonState &lt;&gt; 0 ; If the result is non-zero, the mouse was set to left-handed before the above DLL call
        {
            buttonState := 1
        }
        RegWrite, REG_DWORD, %reg_KeyName%, %reg_ValueName%, %buttonState%
    }
    tmpInt := DllCall("user32.dll\SwapMouseButton", "UInt", buttonState)

Return

F5 &amp; z::
    buttonState := DllCall("user32.dll\SwapMouseButton", "UInt", 1) ; Set left-handed mouse
    if buttonState &lt;&gt; 0 ; If the result is non-zero, the mouse was set to left-handed before the above DLL call
    {
        buttonState := 0
        tmpInt := DllCall("user32.dll\SwapMouseButton", "UInt", 0) ; Set right-handed mouse
        ToolTip, Right Handed
    }
    else
    {
        buttonState := 1
        ToolTip, Left Handed
    }
    RegWrite, REG_DWORD, %reg_KeyName%, %reg_ValueName%, %buttonState%

    SetTimer, tRemoveToolTip, -3000 ; Whith negative period, the timer will run only once
Return


; Function to monitor the WM_WTSSESSION_CHANGE and WM_POWERBROADCAST messages
f_WM_Monitor(wParam, lParam, msg)
{

Global reg_KeyName, reg_ValueName
Global msg_WM_WTSSESSION_CHANGE, msg_WM_POWERBROADCAST

    ; Lock or Suspend
    if ((msg = msg_WM_WTSSESSION_CHANGE and wParam = 7) or (msg = msg_WM_POWERBROADCAST and wParam = 4))
    {
        ; Get mouse buttons' state and store it in the registry. Required if the mouse buttons were swapped using the
        ; Control Panel and not by using the script
        buttonState := DllCall("user32.dll\SwapMouseButton", "UInt", 1) ; Note: Sets left-handed mouse
        if buttonState &lt;&gt; 0 ; If the result is non-zero, the mouse was set to left-handed before the above DLL call
            RegWrite, REG_DWORD, %reg_KeyName%, %reg_ValueName%, 1
        else
            RegWrite, REG_DWORD, %reg_KeyName%, %reg_ValueName%, 0
    }

    ; Unlock
    if ((msg = msg_WM_WTSSESSION_CHANGE and wParam = 8) or (msg = msg_WM_POWERBROADCAST and wParam = 7))
    {
        ; Synaptics driver and Windows 10 issues might reset the mouse buttons to right-handed mouse after unlock/wake-up
        ; The timer is to make sure that the state of the mouse buttons is set to what it was before the computer was locked/suspended
        SetTimer, tSetMouseButtons, -1000 ; With negarive period, the timer will run only once
    }
}
; Timers
tRemoveToolTip:
    ToolTip
Return
tSetMouseButtons:
    RegRead, buttonState, %reg_KeyName%, %reg_ValueName%
    tmpInt := DllCall("user32.dll\SwapMouseButton", "UInt", buttonState)
Return
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ  F5 &amp; z 切换鼠标左右键    ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 000012-1467
 
b100(timeout = 400, keyOverride := "")              ; keyOverride 作用是调用函数时，能指定一个按键，而不是总是使用 A_ThisHotKey 来获取当前热键
{
    tout := timeout / 1000
    key := keyOverride ? keyOverride : RegExReplace(A_ThisHotKey, "[\*\~\$\#\+\!\^]")
    Loop 
{
        t := A_TickCount
        KeyWait %key%
        Pattern .= A_TickCount - t &gt; timeout
        KeyWait %key%, DT%tout%
        If (ErrorLevel)
            Return Pattern
    }
}
;-----------------------------------------------------------------------------------
+F12::
   p := b100()

          If (p = "0")
	Run ms-settings:network-proxy            ;------------------------- 代理 1

   Else If (p = "00")
	Run control.exe sysdm.cpl`,`,3               ;---------------------环境变量 2

   Else If (p = "000")
	;Run compMgmtLauncher
              

	run devmgmt.msc                                  ;------------------ 设备管理器 4
		
   Else If (p = "1")　
;Run, C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Administrative Tools\Task Scheduler.lnk
Run, C:\3\Windows11Manager\App\MyTask.exe ;------------------- 计划任务  5

   Else
{
	;Run dcomcnfg                                    ;------------------------组件服务 6  次数5次以上
	Run mmc 
}
return
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ   F12  代理 变量 管理 控制台 组件服务    ΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 000015-1571
+F11::
   p := b100()

          If (p = "0")
	Run control                                            ;---------------------控制面板 1
	;Run control.exe  main.cpl`,`,2
	;Run control.exe sysdm.cpl`,`,2
	;Run control.exe  intl.cpl`,`,0
	;Run  intl.cpl
	;Run control.exe ncpa.cpl 
   Else If (p = "00")
Run, %A_ComSpec% /k ipconfig  ; 打开 CMD 并直接运行 ipconfig   ; ipconfig 2  C:\Windows\system32\cmd.exe
		
   Else If (p = "000")　　
	Run gpedit.msc                                      ;-----------------------组策略 3

   Else If (p = "0000")
	;Run ncpa.cpl                                          ;---------------------网络连接 4
	;Run shell:::{8E908FC9-BECC-40f6-915B-F4CA0E70D03D}
	Run control.exe /name Microsoft.NetworkAndSharingCenter

   Else If (p = "1")　　
{
               Run compmgmt.msc                             ;------------------ 计算机管理 3
	;Run shrpubw
	;Run fsmgmt.msc                                    ;-------------------共享文件夹   长按
;Run C:\Windows\System32\net1.exe
;Run C:\Windows\System32\net.exe
}
return
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ F11 控制面板 IP 组策略 网络连接 共享  ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 000016-1593

+F9::
   p := b100()

          If (p = "0")			         ; ---------------------OpenAI
	send, sk-yNdE8YSAKoGiEd6KB36e2c85709443448bB61f12Da62B5D0

   Else If (p = "00")			         ; ---------------------OpenAI
send, https://free.v36.cm/v1
		
   Else If (p = "000")			         ; ---------------------Gemini
send, AIzaSyBQhKa0w2NieB6hVq_VVCi_ZTMH7_wI5IE

   Else If (p = "0000")			         ; ---------------------Gemini
send, https://gf.ser.zbb25.filegear-sg.me

   Else If (p = "1")　　{
send, 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
}                               			         ; ---------------------Github
return
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ F9 ai面板输入内容  ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 000016-1593

+F10::
   p := b100()

          If (p = "0")                                                  ; ----------------OpenRouter
	send, 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

   Else If (p = "00")                                                ; ----------------OpenRouter
send, deepseek/deepseek-r1:free
	
   Else If (p = "000")                                              ; -------------------Cloudflare
send, iDhO9tkWnKyAg7AqRxHviCUZ7L3VeK8filQ7Kut2

   Else If (p = "0000")                                            ; -------------------Cloudflare
send, 5e13acfeb51991ab52af94da59e959a2

   Else If (p = "1")　　
{
send, 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
}
return
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ F10 ai面板输入内容  ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 000016-1593

+F5::
send, !j
   p := b100()

          If (p = "0")
	run D:\ahk1.0\Lib\CF\V6优选.exe
	
   Else If (p = "00")
{
	o=C:\0　　T~1\0\9OFFIC~1\9OFFIC~1\Office16\EXCEL.EXE
	1=D:\ahk1.0\US-6.csv
	2=D:\ahk1.0\AS-6.csv
	3=D:\ahk1.0\EU-6.csv
		Run,%o% "%1%" "%2%" "%3%" "%4%"
}

   Else If (p = "000")
              run D:\ahk1.0\Lib\CF\V4优选.exe

   Else If (p = "0000")
{
	o=C:\0　　T~1\0\9OFFIC~1\9OFFIC~1\Office16\EXCEL.EXE
	1=D:\ahk1.0\US-4.csv
	2=D:\ahk1.0\EU-4.csv
	3=D:\ahk1.0\AS-4.csv
		Run,%o% "%1%" "%2%" "%3%" "%4%"
}

   Else If (p = "00000")
              run D:\ahk1.0\CDNym.txt

   Else If (p = "1")　　
{
              run D:\ahk1.0\Lib\CF\优选域名.exe
}
	return
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ +F5 优选  ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 000016-1593

;#Persistent
SetWorkingDir %A_ScriptDir%

~CapsLock::
if (A_PriorHotkey != "CapsLock" or A_TimeSincePriorHotkey &gt; 400)
     {
    ; 这是第一次点击
    KeyWait, CapsLock
    KeyWait, CapsLock, D T0.4   ;等待400毫秒看是否会有第二次点击
    if (ErrorLevel)
{
        Send, !p                                                        ;------------------------- 单击
        Sleep, 100
        Send, s
}
    else
	{
        ; 可能是双击或三击 双击后有轻微的延迟，等1小段时间来确定是否有第3次点击
        KeyWait, CapsLock
        KeyWait, CapsLock, D T0.4
        if (ErrorLevel)
{
            Send, !p                                                    ;------------------------- 双击
            Sleep, 100
Send, s
            Sleep, 100
 Send, !p
            Sleep, 1000
            Send, {down 12}{Enter}
}
    else
	{
        ; 可能是双击或三击 双击后有轻微的延迟，等1小段时间来确定是否有第3次点击
        KeyWait, CapsLock
        KeyWait, CapsLock, D T0.4
        if (ErrorLevel)
{
            Send, !p                                                    ;------------------------- 双击
            Sleep, 100
            Send, 8
}
        else
{
            KeyWait, CapsLock                                  ;------------------------- 三击
            Send, !p
            Sleep, 100
            Send, 0
}
	}
     }
}
return
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ CapsLock  浏览器  1全局 2auto 3直连   ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 000017-1688

 &gt;^q::
ControlGetFocus, control, A
SendMessage, 0x115, 2, , %control%, A
return

;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ  &gt;^q 上一页   ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 000018-1698

 &gt;^e::
ControlGetFocus, control, A
SendMessage, 0x115, 3, , %control%, A
return

;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ  &gt;^e 下一页   ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 000019-1708

F5 &amp; t::
loop, 2
{
var := 0
InputBox, time, KevZ:计时器 请输入一个时间__分钟
time := time*60000
Sleep,%time%
loop, 2
{
var += 180
;SoundBeep, var, 900
SoundPlay, %A_WinDir%\Media\Ring10.wav                                                  ; --------- C:\Windows\Media\Ring10.wav
}
msgbox 时间到！！！! ! ! ! ! ! !
return
}
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ F5 &amp; t  计时器   ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 000020-1660

#IfWinActive ahk_class WindowsForms10.Window.8.app.0.2bf8098_r6_ad1
:*b:++::610712一2550800一122一018{Bs 13}{left 2}{Bs}{left 4}{Bs 4}{Enter}   ;BS 回退13，left 左移 Enter确认 输入+2成功替换
#IfWinActive
;ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ   ++ ka让零部件品质大幅提升，epast    ΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞΞ 0000001-1665

; 💢⭐💢⭐💢⭐💢⭐💢⭐💢⭐    杂类   操作   ⭐💢⭐💢⭐💢⭐💢⭐💢⭐💢⭐💢
; ➰➰➰➰➰➰➰➰➰➰   选行   选段   ➰➰➰➰➰➰➰➰➰➰➰
</code></pre></div>
<div style="font-size:small;margin-top:8px;float:right;">转载请注明出处</div>

</div>
    <div id="footer"><div id="footer1">Copyright © <span id="copyrightYear"></span> <a href="https://z.zcr4.ip-ddns.com">妑🔭差</a></div>
<div id="footer2"><span id="filingNum"><a href="https://beian.miit.gov.cn/" target="_blank">英ICP档20250105案</a> • </span>
    <span id="runday"></span><span>Powered by <a href="https://meekdai.com/Gmeek.html" target="_blank">Gmeek</a></span>
</div>

<script>
var now=new Date();
document.getElementById("copyrightYear").innerHTML=now.getFullYear();

if("02/16/2015"!=""){
    var startSite=new Date("02/16/2015");
    var diff=now.getTime()-startSite.getTime();
    var diffDay=Math.floor(diff/(1000*60*60*24));
    document.getElementById("runday").innerHTML="网站运行"+diffDay+"天"+" • ";
}
</script></div>
</body>
<script>
var IconList={'sun': 'M8 10.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5zM8 12a4 4 0 100-8 4 4 0 000 8zM8 0a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0V.75A.75.75 0 018 0zm0 13a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0v-1.5A.75.75 0 018 13zM2.343 2.343a.75.75 0 011.061 0l1.06 1.061a.75.75 0 01-1.06 1.06l-1.06-1.06a.75.75 0 010-1.06zm9.193 9.193a.75.75 0 011.06 0l1.061 1.06a.75.75 0 01-1.06 1.061l-1.061-1.06a.75.75 0 010-1.061zM16 8a.75.75 0 01-.75.75h-1.5a.75.75 0 010-1.5h1.5A.75.75 0 0116 8zM3 8a.75.75 0 01-.75.75H.75a.75.75 0 010-1.5h1.5A.75.75 0 013 8zm10.657-5.657a.75.75 0 010 1.061l-1.061 1.06a.75.75 0 11-1.06-1.06l1.06-1.06a.75.75 0 011.06 0zm-9.193 9.193a.75.75 0 010 1.06l-1.06 1.061a.75.75 0 11-1.061-1.06l1.06-1.061a.75.75 0 011.061 0z', 'moon': 'M9.598 1.591a.75.75 0 01.785-.175 7 7 0 11-8.967 8.967.75.75 0 01.961-.96 5.5 5.5 0 007.046-7.046.75.75 0 01.175-.786zm1.616 1.945a7 7 0 01-7.678 7.678 5.5 5.5 0 107.678-7.678z', 'sync': 'M1.705 8.005a.75.75 0 0 1 .834.656 5.5 5.5 0 0 0 9.592 2.97l-1.204-1.204a.25.25 0 0 1 .177-.427h3.646a.25.25 0 0 1 .25.25v3.646a.25.25 0 0 1-.427.177l-1.38-1.38A7.002 7.002 0 0 1 1.05 8.84a.75.75 0 0 1 .656-.834ZM8 2.5a5.487 5.487 0 0 0-4.131 1.869l1.204 1.204A.25.25 0 0 1 4.896 6H1.25A.25.25 0 0 1 1 5.75V2.104a.25.25 0 0 1 .427-.177l1.38 1.38A7.002 7.002 0 0 1 14.95 7.16a.75.75 0 0 1-1.49.178A5.5 5.5 0 0 0 8 2.5Z', 'home': 'M6.906.664a1.749 1.749 0 0 1 2.187 0l5.25 4.2c.415.332.657.835.657 1.367v7.019A1.75 1.75 0 0 1 13.25 15h-3.5a.75.75 0 0 1-.75-.75V9H7v5.25a.75.75 0 0 1-.75.75h-3.5A1.75 1.75 0 0 1 1 13.25V6.23c0-.531.242-1.034.657-1.366l5.25-4.2Zm1.25 1.171a.25.25 0 0 0-.312 0l-5.25 4.2a.25.25 0 0 0-.094.196v7.019c0 .138.112.25.25.25H5.5V8.25a.75.75 0 0 1 .75-.75h3.5a.75.75 0 0 1 .75.75v5.25h2.75a.25.25 0 0 0 .25-.25V6.23a.25.25 0 0 0-.094-.195Z', 'github': 'M8 0c4.42 0 8 3.58 8 8a8.013 8.013 0 0 1-5.45 7.59c-.4.08-.55-.17-.55-.38 0-.27.01-1.13.01-2.2 0-.75-.25-1.23-.54-1.48 1.78-.2 3.65-.88 3.65-3.95 0-.88-.31-1.59-.82-2.15.08-.2.36-1.02-.08-2.12 0 0-.67-.22-2.2.82-.64-.18-1.32-.27-2-.27-.68 0-1.36.09-2 .27-1.53-1.03-2.2-.82-2.2-.82-.44 1.1-.16 1.92-.08 2.12-.51.56-.82 1.28-.82 2.15 0 3.06 1.86 3.75 3.64 3.95-.23.2-.44.55-.51 1.07-.46.21-1.61.55-2.33-.66-.15-.24-.6-.83-1.23-.82-.67.01-.27.38.01.53.34.19.73.9.82 1.13.16.45.68 1.31 2.69.94 0 .67.01 1.3.01 1.49 0 .21-.15.45-.55.38A7.995 7.995 0 0 1 0 8c0-4.42 3.58-8 8-8Z', 'copy': 'M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 0 1 0 1.5h-1.5a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-1.5a.75.75 0 0 1 1.5 0v1.5A1.75 1.75 0 0 1 9.25 16h-7.5A1.75 1.75 0 0 1 0 14.25Z M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0 1 14.25 11h-7.5A1.75 1.75 0 0 1 5 9.25Zm1.75-.25a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25Z', 'check': 'M13.78 4.22a.75.75 0 0 1 0 1.06l-7.25 7.25a.75.75 0 0 1-1.06 0L2.22 9.28a.751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018L6 10.94l6.72-6.72a.75.75 0 0 1 1.06 0Z'};
var utterancesLoad=0;

let themeSettings={
    "dark": ["dark","moon","#00f0ff","dark-blue"],
    "light": ["light","sun","#ff5000","github-light"],
    "auto": ["auto","sync","","preferred-color-scheme"]
};
function changeTheme(mode, icon, color, utheme){
    document.documentElement.setAttribute("data-color-mode",mode);
    document.getElementById("themeSwitch").setAttribute("d",value=IconList[icon]);
    document.getElementById("themeSwitch").parentNode.style.color=color;
    if(utterancesLoad==1){utterancesTheme(utheme);}
}
function modeSwitch(){
    let currentMode=document.documentElement.getAttribute('data-color-mode');
    let newMode = currentMode === "light" ? "dark" : currentMode === "dark" ? "auto" : "light";
    localStorage.setItem("meek_theme", newMode);
    if(themeSettings[newMode]){
        changeTheme(...themeSettings[newMode]);
    }
}
function utterancesTheme(theme){
    const message={type:'set-theme',theme: theme};
    const iframe=document.getElementsByClassName('utterances-frame')[0];
    iframe.contentWindow.postMessage(message,'https://utteranc.es');
}
if(themeSettings[theme]){changeTheme(...themeSettings[theme]);}
console.log("\n %c Gmeek last https://github.com/Meekdai/Gmeek \n","padding:5px 0;background:#02d81d;color:#fff");
</script>

<script>
document.getElementById("pathHome").setAttribute("d",IconList["home"]);
document.getElementById("pathIssue").setAttribute("d",IconList["github"]);




document.addEventListener('DOMContentLoaded', () => {
    const createClipboardHTML = (codeContent, additionalClasses = '') => `
        <pre class="notranslate"><code class="notranslate">${codeContent}</code></pre>
        <div class="clipboard-container position-absolute right-0 top-0 ${additionalClasses}">
            <clipboard-copy class="ClipboardButton btn m-2 p-0" role="button" style="display: inherit;">
                <svg height="16" width="16" class="octicon octicon-copy m-2"><path d="${IconList["copy"]}"></path></svg>
                <svg height="16" width="16" class="octicon octicon-check color-fg-success m-2 d-none"><path d="${IconList["check"]}"></path></svg>
            </clipboard-copy>
            <div class="copy-feedback">Copied!</div>
        </div>
    `;

    const handleCodeElements = (selector = '') => {
        document.querySelectorAll(selector).forEach(codeElement => {
            const codeContent = codeElement.innerHTML;
            const newStructure = document.createElement('div');
            newStructure.className = 'snippet-clipboard-content position-relative overflow-auto';
            newStructure.innerHTML = createClipboardHTML(codeContent);

            const parentElement = codeElement.parentElement;
            if (selector.includes('highlight')) {
                parentElement.insertBefore(newStructure, codeElement.nextSibling);
                parentElement.removeChild(codeElement);
            } else {
                parentElement.parentElement.replaceChild(newStructure, parentElement);
            }
        });
    };

    handleCodeElements('pre.notranslate > code.notranslate');
    handleCodeElements('div.highlight > pre.notranslate');

    let currentFeedback = null;
    document.querySelectorAll('clipboard-copy').forEach(copyButton => {
        copyButton.addEventListener('click', () => {
            const codeContent = copyButton.closest('.snippet-clipboard-content').innerText;
            const tempTextArea = document.createElement('textarea');
            tempTextArea.value = codeContent;
            document.body.appendChild(tempTextArea);
            tempTextArea.select();
            document.execCommand('copy');
            document.body.removeChild(tempTextArea);

            const copyIcon = copyButton.querySelector('.octicon-copy');
            const checkIcon = copyButton.querySelector('.octicon-check');
            const copyFeedback = copyButton.nextElementSibling;

            if (currentFeedback && currentFeedback !== copyFeedback) {currentFeedback.style.display = 'none';}
            currentFeedback = copyFeedback;

            copyIcon.classList.add('d-none');
            checkIcon.classList.remove('d-none');
            copyFeedback.style.display = 'block';
            copyButton.style.borderColor = 'var(--color-success-fg)';

            setTimeout(() => {
                copyIcon.classList.remove('d-none');
                checkIcon.classList.add('d-none');
                copyFeedback.style.display = 'none';
                copyButton.style.borderColor = '';
            }, 2000);
        });
    });
});

</script>
<script src='https://blog.meekdai.com/Gmeek/plugins/GmeekTOC.js'></script>

</html>
